C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 1   


C51 COMPILER V9.52.0.0, COMPILATION OF MODULE NO_2
OBJECT MODULE PLACED IN No.2.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil4\C51\BIN\C51.EXE No.2.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*---------------------------------------------------------------------*/
   2          /* --- STC MCU Limited ------------------------------------------------*/
   3          /* --- STC15F4K60S4 系列 定时器1的16位自动重装载模式举例---------------*/
   4          /* --- Mobile: (86)13922805190 -------------- -------------------------*/
   5          /* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
   6          /* --- Tel: 86-0513-55012928,55012929,55012966-------------------------*/
   7          /* --- Web: www.STCMCU.com --------------------------------------------*/
   8          /* --- Web: www.GXWMCU.com --------------------------------------------*/
   9          /* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
  10          /* 如果要在文章中应用此代码,请在文章中注明使用了STC的资料及程序        */
  11          /*---------------------------------------------------------------------*/
  12          
  13          //本示例在Keil开发环境下请选择Intel的8058芯片型号进行编译
  14          //若无特别说明,工作频率一般为11.0592MHz
  15          
  16          
  17          #include "reg51.h"
  18          
  19          #include "intrins.h"
  20          
  21          typedef unsigned char BYTE;
  22          typedef unsigned int WORD;
  23          
  24          #define scd char 
  25          #define ucd unsigned char 
  26          #define ucx unsigned char xdata
  27          #define ucc unsigned char code
  28          #define ncx signed char xdata
  29          #define sid int 
  30          #define uid unsigned int data
  31          #define uix unsigned int xdata
  32          
  33          //-----------------------------------------------
  34          
  35          #define FOSC 11059200L          //系统频率
  36          #define BAUD 115200             //串口波特率
  37          
  38          #define NONE_PARITY     0       //无校验
  39          #define ODD_PARITY      1       //奇校验
  40          #define EVEN_PARITY     2       //偶校验
  41          #define MARK_PARITY     3       //标记校验
  42          #define SPACE_PARITY    4       //空白校验
  43          
  44          #define PARITYBIT EVEN_PARITY   //定义校验位
  45          
  46          
  47          sfr P0M1 = 0x93;
  48          sfr P0M0 = 0x94;
  49          sfr P1M1 = 0x91;
  50          sfr P1M0 = 0x92;
  51          sfr P2M1 = 0x95;
  52          sfr P2M0 = 0x96;
  53          sfr P3M1 = 0xb1;
  54          sfr P3M0 = 0xb2;
  55          sfr P4M1 = 0xb3;
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 2   

  56          sfr P4M0 = 0xb4;
  57          sfr P5M1 = 0xC9;
  58          sfr P5M0 = 0xCA;
  59          sfr P6M1 = 0xCB;
  60          sfr P6M0 = 0xCC;
  61          sfr P7M1 = 0xE1;
  62          sfr P7M0 = 0xE2;
  63          sfr P4   = 0xc0;
  64          sfr AUXR = 0x8e;                    //Auxiliary register
  65          
  66          
  67          
  68          
  69          bit busy;
  70          
  71          
  72          sfr P_SW1   = 0xA2;             //外设功能切换寄存器1
  73          
  74          #define S1_S0 0x40              //P_SW1.6
  75          #define S1_S1 0x80              //P_SW1.7
  76          void SendData(BYTE dat);
  77          void SendString(char *s);
  78          
  79          /////定时器2
  80          sfr IE2       = 0xaf;               //中断使能寄存器2
  81          sfr T2H       = 0xD6;               //定时器2高8位
  82          sfr T2L       = 0xD7;               //定时器2低8位
  83          /////
  84          
  85          
  86          unsigned int count_nei;
  87          
  88          
  89          //===================================================================================//
  90          //===================================================================================//
  91          //                               function    串口中断
  92          //===================================================================================//
  93          //===================================================================================//
  94          
  95          //sfr  AUXR       =   0x8e;       //辅助寄存器                              
  96          /*
  97          sfr ADC_CONTR   =   0xBC;           //ADC控制寄存器
  98          sfr ADC_RES     =   0xBD;           //ADC高8位结果
  99          sfr ADC_RESL     =   0xBE;           //ADC高8位结果
 100          sfr ADC_LOW2    =   0xBE;           //ADC低2位结果
 101          sfr P1ASF       =   0x9D;           //P1口第2功能控制寄存器
 102          sfr CLK_DIV     =   0X97;
 103          
 104          #define ADC_POWER   0x80            //ADC电源控制位
 105          #define ADC_FLAG    0x10            //ADC完成标志
 106          #define ADC_START   0x08            //ADC起始控制位
 107          #define ADC_SPEEDLL 0x00            //540个时钟
 108          #define ADC_SPEEDL  0x20            //360个时钟
 109          #define ADC_SPEEDH  0x40            //180个时钟
 110          #define ADC_SPEEDHH 0x60            //90个时钟
 111          */
 112          
 113          /*----------------------------
 114          软件延时
 115          ----------------------------*/
 116          void Delay(WORD n)
 117          {
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 3   

 118   1          WORD x;
 119   1      
 120   1          while (n--)
 121   1          {
 122   2              x = 5000;
 123   2              while (x--);
 124   2          }
 125   1      }
 126          
 127          /*----------------------------*/
 128          //读取ADC结果
 129          /*
 130          #define ads 1
 131          int adz;
 132          void GetADCResult()
 133          {
 134              if(ADC_CONTR & ADC_FLAG){
 135                  ADC_CONTR &= ~ADC_FLAG; 
 136                  adz =  ADC_RES;
 137                  ADC_CONTR = ADC_POWER | 0 | ADC_START |ADC_SPEEDHH; 
 138              }
 139          }
 140          */
 141          
 142          /*----------------------------
 143          初始化ADC
 144          ----------------------------*/
 145          /*
 146          void InitADC()
 147          {
 148              P1ASF = 0x01;                   //设置 C口为AD口
 149              ADC_RES = 0;                    //清除结果寄存器
 150              ADC_CONTR = ADC_POWER | ADC_SPEEDLL | 0 | ADC_START;
 151              Delay(2);                       //ADC上电并延时
 152          }
 153          */
 154          //-----------------------------------------------------------------------------------//
 155          //-----------------------------------------------------------------------------------//
 156          //                                  function end
 157          //-----------------------------------------------------------------------------------//
 158          //-----------------------------------------------------------------------------------//
 159          
 160          //===================================================================================//
 161          //===================================================================================//
 162          //                               function    串口中断
 163          //===================================================================================//
 164          //===================================================================================//
 165          /*-------------------------------------------smg 函数开始--------------------------------------------*/
 166          //                                                                                                  //
 167          //                                                                                                  //
 168          //                                                                                                  //
 169          //////////////////////////////////////////////////////////////////////////////////////////////////////
 170          //////////////////////////////////////////////////////////////////////////////////////////////////////
 171          //////////////////////////////////////////////////////////////////////////////////////////////////////
 172          //////////////////////////////////////////////////////////////////////////////////////////////////////
 173          //使用引脚定义
 174          #define smgdata P0
 175          /*
 176          sbit smgcs1 = P1^0;
 177          sbit smgcs2 = P1^1;
 178          sbit smgwr  = P1^2;
 179          */
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 4   

 180          sbit smgcs1 = P1^2;
 181          sbit smgcs2 = P1^1;
 182          sbit smgwr  = P1^3;
 183          //使用数据定义
 184          static scd smgb;
 185          ucd smgdp;
 186          ucd smghc[8] ;
 187          unsigned char code smgdm[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0
             -x8e,0xff};
 188          //小数点函数
 189          #define smgdps(x) smgdp |= 0x80 >> x            //小数点置位
 190          #define smgdpr(x) smgdp &= ~（0x80 >> x ）      //清楚某位小数点
 191          #define smgdpc(x) smgdp = 0;                    //清楚所有小数点
 192          //函    数：smgxhc
 193          //功    能：将数字写入数码管缓存中
 194          //返回参数：无
 195          //输入参数：wz显示数字的起始位置，cd连续显示多少位，sz显示数据内容
 196          void smgxhc(unsigned char wz,unsigned char cd,unsigned int sz){
 197   1              char i ;
 198   1          TR1 = 0;
 199   1              for(i  = cd - 1 ;i >= 0 ; i--){
 200   2                      smghc[wz + i ] = sz % 10;
 201   2                      sz = sz /10;
 202   2              }       
 203   1      /*      
 204   1          i = 0;
 205   1              while(smghc[wz + i] == 0){
 206   1                      if(i == cd -1 )break;
 207   1                      smghc[wz + i ] = 16;
 208   1                      i++;
 209   1              }*/
 210   1          TR1 = 1;
 211   1      }
 212          //函    数：smgrun
 213          //功    能：数码管运行函数，通常放在定时器中
 214          //返回参数：无
 215          //输入参数：无
 216          void smgrun(){
 217   1          ucd i ;
 218   1              smgb += 1 ;
 219   1              smgb = smgb & 0x07;
 220   1              
 221   1              smgcs1 = smgwr = 0;
 222   1              smgdata = 0xff;
 223   1              smgcs1 = smgwr = 1;
 224   1      
 225   1              smgcs2 = smgwr = 0;;
 226   1          smgdata = _cror_(0x7f,smgb);
 227   1              smgcs2 = smgwr = 1;
 228   1      
 229   1              smgcs1 = smgwr = 0;
 230   1          i = smgdp & _cror_(0x80,smgb);
 231   1          if(i !=0)
 232   1              smgdata = smgdm[smghc[smgb]]  & 0x7f;
 233   1          else smgdata = smgdm[smghc[smgb]];
 234   1              smgcs1 = smgwr = 1;
 235   1              
 236   1      
 237   1      }
 238          //-----------------------------------------------------------------------------------//
 239          //-----------------------------------------------------------------------------------//
 240          //                                  function end
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 5   

 241          //-----------------------------------------------------------------------------------//
 242          //-----------------------------------------------------------------------------------//
 243          
 244          
 245          
 246          //===================================================================================//
 247          //===================================================================================//
 248          //                               function    串口中断
 249          //===================================================================================//
 250          //===================================================================================//
 251          void bjrun();
 252          //函    数：tm1_isr
 253          //功    能：定时器T1中断程序
 254          //返回参数：无
 255          //输入参数：无
 256          void tm1_isr() interrupt 3 using 1  
 257          {
 258   1          smgrun();
 259   1          bjrun();
 260   1      }
 261          //函    数：initt1
 262          //功    能：定时器T1复位，11.0592MHz情况下，100微秒，12T，误差0.17%，16位自动重载模式
 263          //返回参数：无
 264          //输入参数：无
 265          void initt1(){
 266   1          AUXR &= 0xBF;   //定时器时钟12T模式
 267   1              TMOD &= 0x0F;   //设置定时器模式
 268   1              TL1 = 0xA4;             //设置定时初值
 269   1              TH1 = 0xFF;             //设置定时初值
 270   1              TF1 = 0;                //清除TF1标志
 271   1              TR1 = 1;                //定时器1开始计时
 272   1          ET1 = 1;        //使能定时器1中断
 273   1      }
 274          
 275          //-----------------------------------------------------------------------------------//
 276          //-----------------------------------------------------------------------------------//
 277          //                                  function end
 278          //-----------------------------------------------------------------------------------//
 279          //-----------------------------------------------------------------------------------//
 280          
 281          
 282          /*定时中断1 函数结束----------------------------------------------------------------------------------*/
 283          
 284          void Delay25us()                //@11.0592MHz
 285          {
 286   1              ucd i;
 287   1      
 288   1              _nop_();
 289   1              _nop_();
 290   1              i = 66;
 291   1              while (--i);
 292   1      }
 293          
 294          
 295          void Delay50ms()                //@11.0592MHz
 296          {
 297   1              unsigned char i, j, k;
 298   1      
 299   1              _nop_();
 300   1              _nop_();
 301   1              i = 3;
 302   1              j = 26;
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 6   

 303   1              k = 223;
 304   1              do
 305   1              {
 306   2                      do
 307   2                      {
 308   3                              while (--k);
 309   3                      } while (--j);
 310   2              } while (--i);
 311   1      }
 312          
 313          //-----------------------------------------------------------------------------------//
 314          //-----------------------------------------------------------------------------------//
 315          //                                  function end
 316          //-----------------------------------------------------------------------------------//
 317          //-----------------------------------------------------------------------------------//
 318          
 319          //===================================================================================//
 320          //===================================================================================//
 321          //                               function    串口中断
 322          //===================================================================================//
 323          //===================================================================================//
 324          
 325          /*128液晶 函数开始-----------------------------------------------------------------------------------*/
 326          //                                                                                                  //
 327          //                                                                                                  //
 328          //                                                                                                  //
 329          //////////////////////////////////////////////////////////////////////////////////////////////////////
 330          //////////////////////////////////////////////////////////////////////////////////////////////////////
 331          //////////////////////////////////////////////////////////////////////////////////////////////////////
 332          //////////////////////////////////////////////////////////////////////////////////////////////////////
 333          #define dyjdata P0
 334          sbit dyjcs2 =  P1^4;
 335          sbit dyjcs1 =  P1^5;
 336          sbit dyje   =  P1^6;
 337          sbit dyjrs  =  P1^7;
 338          
 339          
 340          
 341          code unsigned char dyj32[][32] = {
 342          //-- 朝 --
 343                0x00,0xE4,0xA4,0xA4,0xBF,0xA4,0xA6,0xF4,
 344                0x20,0xFE,0x22,0x22,0x22,0xFF,0x02,0x00,
 345                0x10,0x17,0x12,0x12,0xFE,0x12,0x1A,0x93,
 346                0x40,0x3F,0x02,0x42,0x82,0x7F,0x00,0x00,
 347          //-- 辞 --
 348                0x44,0x44,0x44,0xFE,0x43,0x62,0x40,0x08,
 349                0x28,0x49,0x0E,0x48,0x2C,0x88,0x00,0x00,
 350                0x00,0xFE,0x42,0x43,0x42,0xFF,0x02,0x09,
 351                0x09,0x09,0xFF,0x09,0x0D,0x09,0x01,0x00,
 352          //-- 白 --
 353                0x00,0x00,0xF8,0x08,0x0C,0x0A,0x09,0x08,
 354                0x08,0x08,0x08,0x08,0xFC,0x08,0x00,0x00,
 355                0x00,0x00,0x7F,0x21,0x21,0x21,0x21,0x21,
 356                0x21,0x21,0x21,0x21,0x7F,0x00,0x00,0x00,
 357          //-- 帝 --
 358                0x80,0x60,0x24,0x24,0x2C,0x34,0x25,0xE6,
 359                0x24,0x34,0x2C,0xA6,0x24,0xA0,0x60,0x00,
 360                0x00,0x00,0x00,0x3F,0x01,0x01,0x01,0xFF,
 361                0x01,0x11,0x21,0x1F,0x01,0x00,0x00,0x00,
 362          //-- 彩 --
 363                0x84,0x8C,0xB4,0x84,0xDA,0x82,0x92,0x8D,
 364                0x20,0x10,0x08,0x84,0x46,0x60,0x00,0x00,
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 7   

 365                0x20,0x10,0x08,0x06,0xFF,0x02,0x04,0x0C,
 366                0x80,0x42,0x21,0x10,0x08,0x0C,0x00,0x00,
 367          //-- 云 --
 368                0x40,0x40,0x40,0x44,0x44,0x44,0xC4,0x44,
 369                0x44,0x44,0x46,0x44,0x40,0x60,0x40,0x00,
 370                0x00,0x00,0x40,0x60,0x58,0x46,0x41,0x40,
 371                0x40,0x40,0x50,0x60,0xC0,0x00,0x00,0x00,
 372          //-- 间 --
 373                0x00,0xF8,0x01,0x02,0xF6,0x10,0x12,0x12,
 374                0x12,0x12,0xFA,0x12,0x02,0xFF,0x02,0x00,
 375                0x00,0xFF,0x00,0x00,0x3F,0x11,0x11,0x11,
 376                0x11,0x11,0x3F,0x40,0x80,0x7F,0x00,0x00,
 377          //-- 千 --
 378                0x80,0x80,0x84,0x84,0x84,0x84,0x84,0xFC,
 379                0x82,0x82,0x83,0x82,0x80,0xC0,0x80,0x00,
 380                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
 381                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 382          //-- 里 --
 383                0x00,0x00,0xFE,0x12,0x12,0x12,0x12,0xFE,
 384                0x12,0x12,0x12,0x12,0xFF,0x02,0x00,0x00,
 385                0x40,0x48,0x49,0x49,0x49,0x49,0x49,0x7F,
 386                0x49,0x49,0x49,0x49,0x4D,0x68,0x40,0x00,
 387          //-- 江 --
 388                0x10,0x21,0x62,0x06,0x80,0x04,0x04,0x04,
 389                0x04,0xFC,0x04,0x04,0x06,0x04,0x00,0x00,
 390                0x04,0x04,0xFE,0x01,0x20,0x20,0x20,0x20,
 391                0x20,0x3F,0x20,0x20,0x20,0x30,0x20,0x00,
 392          //-- 陵 --
 393                0x00,0xFE,0x02,0x22,0xDA,0x06,0x20,0xA4,
 394                0x64,0xA4,0x3F,0x24,0x66,0xB4,0x20,0x00,
 395                0x00,0xFF,0x08,0x10,0x08,0x87,0x89,0x44,
 396                0x46,0x29,0x11,0x29,0x47,0xC0,0x41,0x00,
 397          //-- 一 --
 398                0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
 399                0x80,0x80,0x80,0x80,0x80,0xC0,0x80,0x00,
 400                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 401                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 402          //-- 日 --
 403                0x00,0x00,0x00,0xFE,0x82,0x82,0x82,0x82,
 404                0x82,0x82,0x82,0xFF,0x02,0x00,0x00,0x00,
 405                0x00,0x00,0x00,0x7F,0x20,0x20,0x20,0x20,
 406                0x20,0x20,0x20,0x7F,0x00,0x00,0x00,0x00,
 407          //-- 还 --
 408                0x20,0x22,0xEC,0x00,0x04,0x04,0x04,0x84,
 409                0xE4,0x1C,0x84,0x04,0x04,0x06,0x04,0x00,
 410                0x40,0x20,0x1F,0x20,0x44,0x42,0x41,0x40,
 411                0x5F,0x40,0x40,0x41,0x43,0x66,0x20,0x00,
 412          //-- 两 --
 413                0x02,0xF2,0x12,0x12,0x12,0xFE,0x12,0x12,
 414                0x12,0xFE,0x12,0x12,0x12,0xFB,0x12,0x00,
 415                0x00,0xFF,0x10,0x08,0x04,0x03,0x14,0x08,
 416                0x04,0x03,0x04,0x48,0x98,0x7F,0x00,0x00,
 417          //-- 岸 --
 418                0x00,0x00,0xEE,0x28,0xA8,0xA8,0xA8,0xAF,
 419                0xA8,0xA8,0xA8,0xE8,0xAE,0x20,0x00,0x00,
 420                0x40,0x20,0x1F,0x04,0x04,0x04,0x04,0x04,
 421                0xFF,0x04,0x04,0x04,0x06,0x04,0x00,0x00,
 422          //-- 猿 --
 423                0x40,0x22,0x14,0x08,0xF4,0x12,0xD5,0x54,
 424                0x54,0x5F,0x54,0x54,0xF6,0x54,0x10,0x00,
 425                0x08,0x44,0x82,0x41,0x3F,0x20,0x13,0xFE,
 426                0x42,0x26,0x0A,0x12,0x2B,0x64,0x20,0x00,
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 8   

 427          //-- 声 --
 428                0x04,0x14,0xD4,0x54,0x54,0x54,0x54,0xDF,
 429                0x54,0x54,0x54,0x54,0xF4,0x56,0x04,0x00,
 430                0x80,0x60,0x1F,0x02,0x02,0x02,0x02,0x03,
 431                0x02,0x02,0x02,0x02,0x07,0x00,0x00,0x00,
 432          //-- 啼 --
 433                0x00,0xFC,0x04,0x04,0xFE,0x84,0x60,0x24,
 434                0x2C,0x35,0xE6,0x34,0x2C,0xA4,0x60,0x00,
 435                0x00,0x1F,0x08,0x08,0x1F,0x00,0x00,0x3F,
 436                0x01,0x01,0xFF,0x01,0x21,0x3F,0x01,0x00,
 437          //-- 不 --
 438                0x02,0x02,0x02,0x02,0x02,0x82,0x42,0xF2,
 439                0x0E,0x42,0x82,0x02,0x02,0x03,0x02,0x00,
 440                0x00,0x08,0x04,0x02,0x01,0x00,0x00,0xFF,
 441                0x00,0x00,0x00,0x01,0x03,0x06,0x00,0x00,
 442          //-- 住 --
 443                0x80,0x40,0x20,0xF8,0x07,0x08,0x08,0x08,
 444                0x09,0xFE,0x08,0x08,0x88,0x0C,0x08,0x00,
 445                0x00,0x00,0x00,0xFF,0x40,0x41,0x41,0x41,
 446                0x41,0x7F,0x41,0x41,0x41,0x61,0x40,0x00,
 447          //-- 轻 --
 448                0x08,0xC8,0xB8,0x8F,0xE8,0x8C,0x48,0x42,
 449                0x22,0x22,0x12,0x1A,0x36,0x22,0x40,0x00,
 450                0x08,0x18,0x08,0x08,0xFF,0x04,0x44,0x42,
 451                0x42,0x42,0x7E,0x42,0x43,0x62,0x40,0x00,
 452          //-- 舟 --
 453                0x80,0x80,0x80,0xFC,0x84,0x86,0x95,0xE4,
 454                0x84,0x84,0x84,0xFE,0x84,0xC0,0x80,0x00,
 455                0x00,0x40,0x20,0x1F,0x00,0x00,0x02,0x0C,
 456                0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,
 457          //-- 已 --
 458                0x00,0x02,0xF2,0x42,0x42,0x42,0x42,0x42,
 459                0x42,0x42,0x42,0xFF,0x02,0x00,0x00,0x00,
 460                0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x40,
 461                0x40,0x40,0x40,0x40,0x40,0x78,0x00,0x00,
 462          //-- 过 --
 463                0x40,0x42,0x44,0xC8,0x00,0x08,0x08,0x48,
 464                0x88,0x08,0x08,0xFF,0x08,0x08,0x00,0x00,
 465                0x00,0x40,0x20,0x1F,0x20,0x40,0x40,0x40,
 466                0x41,0x48,0x50,0x4F,0x40,0x60,0x20,0x00,
 467          //-- 万 --
 468                0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0x44,
 469                0x44,0x44,0x44,0xE4,0x44,0x06,0x04,0x00,
 470                0x00,0x80,0x40,0x20,0x10,0x0E,0x01,0x00,
 471                0x40,0x80,0x40,0x3F,0x00,0x00,0x00,0x00,
 472          //-- 重 --
 473                0x08,0x08,0x0A,0xEA,0xAA,0xAA,0xAA,0xFE,
 474                0xAA,0xAA,0xA9,0xF9,0x29,0x0C,0x08,0x00,
 475                0x40,0x40,0x48,0x4B,0x4A,0x4A,0x4A,0x7F,
 476                0x4A,0x4A,0x4A,0x4B,0x48,0x60,0x40,0x00,
 477          //-- 山 --
 478                0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0xFF,
 479                0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,
 480                0x00,0x7F,0x20,0x20,0x20,0x20,0x20,0x3F,
 481                0x20,0x20,0x20,0x20,0x20,0x7F,0x00,0x00,
 482          
 483          //-- ： --
 484                0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x80,
 485                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 486                0x00,0x00,0x00,0x00,0x31,0x7B,0x7B,0x31,
 487                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 488                
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 9   

 489          //     "，",
 490                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 491                0x00,0x00,0x00,0x46,0x2F,0x1F,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 492          
 493          //"。", 
 494                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 495                0x00,0x38,0x7C,0x44,0x44,0x7C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 496                
 497                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 498                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
 499          };
 500          
 501          code unsigned char   *dyjhzz = "朝辞白帝彩云间千里江陵一日还两岸猿声啼不住轻舟已过万重山：，。 ";
 502          
 503          code unsigned char dyj16[][16] ={
 504              0xF8,0xFC,0x04,0xC4,0x24,0xFC,0xF8,0x00,0x07,0x0F,0x09,0x08,0x08,0x0F,0x07,0x00,  // -0-
 505                  
 506                  0x00,0x10,0x18,0xFC,0xFC,0x00,0x00,0x00,0x00,0x08,0x08,0x0F,0x0F,0x08,0x08,0x00,  // -1-
 507                  
 508                  0x08,0x0C,0x84,0xC4,0x64,0x3C,0x18,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0C,0x00,  // -2-
 509          
 510                  0x08,0x0C,0x44,0x44,0x44,0xFC,0xB8,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,  // -3-
 511                  
 512                  0xC0,0xE0,0xB0,0x98,0xFC,0xFC,0x80,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,  // -4-
 513          
 514                  0x7C,0x7C,0x44,0x44,0xC4,0xC4,0x84,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,  // -5-
 515          
 516                  0xF0,0xF8,0x4C,0x44,0x44,0xC0,0x80,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,  // -6-
 517          
 518                  0x0C,0x0C,0x04,0x84,0xC4,0x7C,0x3C,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,  // -7-
 519          
 520                  0xB8,0xFC,0x44,0x44,0x44,0xFC,0xB8,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,  // -8-
 521          
 522                  0x38,0x7C,0x44,0x44,0x44,0xFC,0xF8,0x00,0x00,0x08,0x08,0x08,0x0C,0x07,0x03,0x00,  // -9-
 523          
 524              0xE0,0xF0,0x98,0x8C,0x98,0xF0,0xE0,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -A-
 525          
 526                  0x04,0xFC,0xFC,0x44,0x44,0xFC,0xB8,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0F,0x07,0x00, // -B-
 527          
 528                  0xF0,0xF8,0x0C,0x04,0x04,0x0C,0x18,0x00,0x03,0x07,0x0C,0x08,0x08,0x0C,0x06,0x00, // -C-
 529          
 530                  0x04,0xFC,0xFC,0x04,0x0C,0xF8,0xF0,0x00,0x08,0x0F,0x0F,0x08,0x0C,0x07,0x03,0x00, // -D-
 531          
 532                  0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00, // -E-
 533          
 534                  0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -F-
 535          
 536                  0xF0,0xF8,0x0C,0x84,0x84,0x8C,0x98,0x00,0x03,0x07,0x0C,0x08,0x08,0x07,0x0F,0x00, // -G-
 537          
 538                  0xFC,0xFC,0x40,0x40,0x40,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -H-
 539          
 540                  0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -I-
 541          
 542                  0x00,0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,0x07,0x0F,0x08,0x08,0x0F,0x07,0x00,0x00, // -J-
 543          
 544                  0x04,0xFC,0xFC,0xC0,0xF0,0x3C,0x0C,0x00,0x08,0x0F,0x0F,0x00,0x01,0x0F,0x0E,0x00, // -K-
 545          
 546                  0x04,0xFC,0xFC,0x04,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00, // -L-
 547          
 548                  0xFC,0xFC,0x38,0x70,0x38,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -M-
 549          
 550                  0xFC,0xFC,0x38,0x70,0xE0,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -N-
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 10  

 551          
 552                  0xF0,0xF8,0x0C,0x04,0x0C,0xF8,0xF0,0x00,0x03,0x07,0x0C,0x08,0x0C,0x07,0x03,0x00, // -O-
 553          
 554                  0x04,0xFC,0xFC,0x44,0x44,0x7C,0x38,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -P-
 555          
 556                  0xF8,0xFC,0x04,0x04,0x04,0xFC,0xF8,0x00,0x07,0x0F,0x08,0x0E,0x3C,0x3F,0x27,0x00, // -Q-
 557          
 558                  0x04,0xFC,0xFC,0x44,0xC4,0xFC,0x38,0x00,0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -R-
 559          
 560                  0x18,0x3C,0x64,0x44,0xC4,0x9C,0x18,0x00,0x06,0x0E,0x08,0x08,0x08,0x0F,0x07,0x00, // -S-
 561          
 562                  0x00,0x1C,0x0C,0xFC,0xFC,0x0C,0x1C,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -T-
 563          
 564                  0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -U-
 565          
 566                  0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,0x01,0x03,0x06,0x0C,0x06,0x03,0x01,0x00, // -V-
 567          
 568                  0xFC,0xFC,0x00,0x80,0x00,0xFC,0xFC,0x00,0x03,0x0F,0x0E,0x03,0x0E,0x0F,0x03,0x00, // -W-
 569          
 570                  0x0C,0x3C,0xF0,0xC0,0xF0,0x3C,0x0C,0x00,0x0C,0x0F,0x03,0x00,0x03,0x0F,0x0C,0x00, // -X-
 571          
 572                  0x00,0x3C,0x7C,0xC0,0xC0,0x7C,0x3C,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -Y-
 573          
 574                  0x1C,0x0C,0x84,0xC4,0x64,0x3C,0x1C,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0E,0x00, // -Z-
 575          
 576              
 577              0x00,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -a-
 578          
 579                  0x04,0xFC,0xFC,0x20,0x60,0xC0,0x80,0x00,0x08,0x0F,0x07,0x08,0x08,0x0F,0x07,0x00, // -b-
 580          
 581                  0xC0,0xE0,0x20,0x20,0x20,0x60,0x40,0x00,0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00, // -c-
 582          
 583                  0x80,0xC0,0x60,0x24,0xFC,0xFC,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -d-
 584          
 585                  0xC0,0xE0,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00, // -e-
 586          
 587                  0x40,0xF8,0xFC,0x44,0x0C,0x18,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -f-
 588          
 589                  0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,0x27,0x6F,0x48,0x48,0x7F,0x3F,0x00,0x00, // -g-
 590          
 591                  0x04,0xFC,0xFC,0x40,0x20,0xE0,0xC0,0x00,0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -h-
 592          
 593                  0x00,0x00,0x20,0xEC,0xEC,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -i-
 594          
 595                  0x00,0x00,0x00,0x00,0x20,0xEC,0xEC,0x00,0x00,0x30,0x70,0x40,0x40,0x7F,0x3F,0x00, // -j-
 596          
 597                  0x04,0xFC,0xFC,0x80,0xC0,0x60,0x20,0x00,0x08,0x0F,0x0F,0x01,0x03,0x0E,0x0C,0x00, // -k-
 598          
 599                  0x00,0x00,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -l-
 600          
 601                  0xE0,0xE0,0x60,0xC0,0x60,0xE0,0xC0,0x00,0x0F,0x0F,0x00,0x0F,0x00,0x0F,0x0F,0x00, // -m-
 602          
 603                  0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x00,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -n-
 604          
 605                  0xC0,0xE0,0x20,0x20,0x20,0xE0,0xC0,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -o-
 606          
 607                  0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x40,0x7F,0x7F,0x48,0x08,0x0F,0x07,0x00, // -p-
 608          
 609                  0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,0x07,0x0F,0x08,0x48,0x7F,0x7F,0x40,0x00, // -q-
 610          
 611                  0x20,0xE0,0xC0,0x60,0x20,0x60,0xC0,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -r-
 612          
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 11  

 613                  0x40,0xE0,0xA0,0x20,0x20,0x60,0x40,0x00,0x04,0x0C,0x09,0x09,0x0B,0x0E,0x04,0x00, // -s-
 614          
 615                  0x20,0x20,0xF8,0xFC,0x20,0x20,0x00,0x00,0x00,0x00,0x07,0x0F,0x08,0x0C,0x04,0x00, // -t-
 616          
 617                  0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -u-
 618          
 619                  0x00,0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,0x00,0x03,0x07,0x0C,0x0C,0x07,0x03,0x00, // -v-
 620          
 621                  0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,0x07,0x0F,0x0C,0x07,0x0C,0x0F,0x07,0x00, // -w-
 622          
 623                  0x20,0x60,0xC0,0x80,0xC0,0x60,0x20,0x00,0x08,0x0C,0x07,0x03,0x07,0x0C,0x08,0x00, // -x-
 624          
 625                  0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,0x47,0x4F,0x48,0x48,0x68,0x3F,0x1F,0x00, // -y-
 626          
 627                  0x60,0x60,0x20,0xA0,0xE0,0x60,0x20,0x00,0x0C,0x0E,0x0B,0x09,0x08,0x0C,0x0C,0x00, // -z-
 628              
 629              0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00  // -:-
 630                  
 631              
 632          };
 633          
 634          code unsigned char   *dyjzmz = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:";
 635          
 636          
 637          void Delay5us()         //@11.0592MHz
 638          {
 639   1              unsigned char i;
 640   1      
 641   1              _nop_();
 642   1              i = 25;
 643   1              while (--i);
 644   1      }
 645          
 646          
 647          void dyjml(unsigned char a){
 648   1          dyjrs = 0;
 649   1          dyjdata = a;
 650   1          dyje = 1;
 651   1          Delay5us();
 652   1          dyje = 0;
 653   1      }
 654          
 655          void dyjsj(unsigned char a){
 656   1          dyjrs = 1;
 657   1          dyjdata = a;
 658   1          dyje  = 1;
 659   1          Delay5us();
 660   1          dyje = 0;
 661   1      }
 662          
 663          void dyjxy(unsigned char x,unsigned char y, unsigned char z,bit fb){
 664   1          unsigned char i;
 665   1          if(y<64){
 666   2              i = 0x40 +y;
 667   2              dyjcs1 = 1;
 668   2              dyjcs2 = 0;
 669   2          }
 670   1          else {
 671   2              i = 0x40 + y - 64;
 672   2              dyjcs1 = 0;
 673   2              dyjcs2 = 1;
 674   2          }
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 12  

 675   1          TR1 = 0;
 676   1          dyjml(i);
 677   1          dyjml(0xb8 + x);
 678   1          if(fb) dyjsj(0xff - z);
 679   1          else dyjsj(z);
 680   1          TR1 = 1;
 681   1      }
 682          
 683          void dyjcsh(unsigned char x,unsigned char y){
 684   1          unsigned int i,j;
 685   1          dyjml(0x3f);
 686   1          dyjml(0xc0);
 687   1          for(i = x; i < y ; i++){
 688   2              for(j = 0; j<128;j++)
 689   2                  dyjxy(i,j,0,0);
 690   2          }        
 691   1          i = 5;j = 100;
 692   1          while(i--) while(j--);;
 693   1      }
 694          
 695          void dyjsz(unsigned char r,unsigned char c, unsigned char s,bit fb){
 696   1          unsigned char i,j,d = 0;
 697   1          //SendData(s+55);SendString("\r\n");
 698   1          for(i = r; i <r+2; i++){
 699   2              for(j = c; j <c+8 ; j++){
 700   3                  dyjxy(i,j,dyj16[s][d++],fb);
 701   3              }
 702   2              dyjcs1 = dyjcs2 = dyje = 0;
 703   2          }
 704   1      }
 705          
 706          void dyjhz(unsigned char r,unsigned char c, unsigned char s,bit fb){
 707   1          unsigned char i,j,d = 0;
 708   1          for(i = r; i <r+2; i++){
 709   2              for(j = c; j <c+16 ; j++){
 710   3                  dyjxy(i,j,dyj32[s][d++],fb);
 711   3              }
 712   2              dyjcs1 = dyjcs2 = dyje = 0;
 713   2          }
 714   1      }
 715          
 716          void dyjzm(unsigned char r,unsigned char c, unsigned char *s,bit fb){
 717   1          unsigned char i,j,d = 0;
 718   1          //SendData(s[0]);SendString("\r\n");
 719   1          for(i = r; i < r + 2; i++){
 720   2              for(j = c; j < c + 8; j++){
 721   3                  dyjxy(i,j,s[d++],fb);
 722   3              }
 723   2              dyjcs1 = dyjcs2 = dyje = 0;
 724   2          }
 725   1      }
 726          /*128液晶 函数结束-----------------------------------------------------------------------------------*/
 727          void djmsz(unsigned char r, unsigned char c, unsigned int s,unsigned char w ,bit fb){
 728   1          while(w-- > 0 ){
 729   2              dyjsz(r,c+8*w,s%10,fb);
 730   2              s /= 10;
 731   2          }
 732   1      }
 733          void djmhz(unsigned char r, unsigned char c, unsigned char *s,bit fb){
 734   1          unsigned char i,j;
 735   1          for(i = 0; s[i] != 0 ;i++){
 736   2              for(j = 0; dyjhzz[j] != 0;j+= 2){
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 13  

 737   3                  if((s[i]==dyjhzz[j])&&(s[i+1]==dyjhzz[j+1])){
 738   4                      //dyjhz(r,c+i*8,dyj32[j],fb);//2017.4.17change
 739   4                      dyjhz(r,c+i*8,j/2,fb);
 740   4                      break;
 741   4                  }
 742   3              }
 743   2          }
 744   1      }
 745          
 746          void djmzm(unsigned char r, unsigned char c, unsigned char *s,bit fb){
 747   1          unsigned char i,j;
 748   1          for(i = 0; s[i]  != '\0' ;i++){
 749   2              for(j = 0; dyjzmz[j] != '\0';j++){
 750   3                  if((s[i]==dyjzmz[j])){
 751   4                      dyjsz(r,c+i*8,j,fb);
 752   4                      break;
 753   4                  }
 754   3              }
 755   2          }
 756   1      }
 757          //-----------------------------------------------------------------------------------//
 758          //-----------------------------------------------------------------------------------//
 759          //                                  function end
 760          //-----------------------------------------------------------------------------------//
 761          //-----------------------------------------------------------------------------------//
 762          
 763          //===================================================================================//
 764          //===================================================================================//
 765          //                               function    串口中断
 766          //===================================================================================//
 767          //===================================================================================//
 768          /*----------------------------
 769          UART 中断服务程序
 770          -----------------------------*/
 771          void Uart() interrupt 4 using 1
 772          {
 773   1          if (RI)
 774   1          {
 775   2              RI = 0;                 //清除RI位
 776   2          }
 777   1          if (TI)
 778   1          {
 779   2              TI = 0;                 //清除TI位
 780   2              busy = 0;               //清忙标志
 781   2          }
 782   1      }
 783          
 784          /*----------------------------
 785          发送串口数据
 786          ----------------------------*/
 787          void SendData(BYTE dat)
 788          {
 789   1        
 790   1          while (busy);               //等待前面的数据发送完成
 791   1          ACC = dat;                  //获取校验位P (PSW.0)
 792   1          if (P)                      //根据P来设置校验位
 793   1          {
 794   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 0;                //设置校验位为0
              #elif (PARITYBIT == EVEN_PARITY)
 797   2              TB8 = 1;                //设置校验位为1
 798   2      #endif
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 14  

 799   2          }
 800   1          else
 801   1          {
 802   2      #if (PARITYBIT == ODD_PARITY)
                      TB8 = 1;                //设置校验位为1
              #elif (PARITYBIT == EVEN_PARITY)
 805   2              TB8 = 0;                //设置校验位为0
 806   2      #endif
 807   2          }
 808   1          busy = 1;
 809   1          SBUF = ACC;                 //写数据到UART数据寄存器
 810   1      }
 811          
 812          /*----------------------------
 813          发送字符串
 814          ----------------------------*/
 815          void SendString(char *s)
 816          {
 817   1          while (*s)                  //检测字符串结束标志
 818   1          {
 819   2              SendData(*s++);         //发送当前字符
 820   2          }
 821   1      }
 822          //-----------------------------------------------------------------------------------//
 823          //-----------------------------------------------------------------------------------//
 824          //                                  function end
 825          //-----------------------------------------------------------------------------------//
 826          //-----------------------------------------------------------------------------------//
 827          
 828          
 829          //===================================================================================//
 830          //===================================================================================//
 831          //                               function    1602液晶
 832          //说明：函数使用前缀  xyj , 函数有写命令，写数据，写字母，写数字，写自制符号5个函数
 833          //函数关系图：
 834          //              xyjzm       xyjsz     xyjzzfh
 835          //                 |          |         |
 836          //                 ----------------------
 837          //                            |
 838          //                     -----------------
 839          //                     |               |
 840          //                   xyjml           xyjsj
 841          //
 842          //===================================================================================//
 843          //===================================================================================//
 844          //引脚定义
 845          sfr P5   =   0xc8;//使用stc头文件的时候不需要
 846          sbit xyje = P4^5;
 847          sbit xyjrs = P5^5;
 848          #define xyjdata P0
 849          //自制字符显示与对应位置宏定义 格式 5*7 #define white   0x00
 850          #define yellow  0x01
 851          #define black   0x02
 852          #define up              0x03
 853          #define down    0x04
 854          #define left    0x05
 855          #define right   0x06
 856          ucx xyjfhz[56] = {
 857                                   0x04,0x0a,0x11,0x11,0x11,0x11,0x0a,0x04,//白球
 858                                   0x04,0x0a,0x1b,0x15,0x15,0x1b,0x0a,0x04,//黄球
 859                                   0x04,0x0e,0x1f,0x1f,0x1f,0x1f,0x0e,0x04,//黑球
 860                                   0x00,0x04,0x0e,0x15,0x04,0x04,0x04,0x00,//向上
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 15  

 861                                   0x00,0x04,0x04,0x04,0x15,0x0e,0x04,0x00,//向下
 862                                   0x00,0x04,0x08,0x1f,0x08,0x04,0x00,0x00,//向左 
 863                                   0x00,0x04,0x02,0x1f,0x02,0x04,0x00,0x00 //向右
 864          };
 865          //函    数：xyjml
 866          //功    能：写入命令道1602液晶屏
 867          //返回参数：无
 868          //输入参数： a液晶控制命令 
 869          void xyjml(ucd a)
 870          {
 871   1           TR1 = 0;
 872   1           xyjrs=0;Delay25us();
 873   1           xyjdata=a;
 874   1           xyje=1;Delay25us();
 875   1           xyje=0;
 876   1           TR1 = 1;
 877   1      }
 878          //函    数：xyjsj
 879          //功    能：写入数据到1602液晶屏
 880          //返回参数：无
 881          //输入参数： a液晶控制shuju 
 882          void xyjsj(ucd a)//这个xyjsj函数只能写一个字节
 883          {
 884   1           TR1 = 0;
 885   1           xyjrs=1;Delay25us();
 886   1           xyjdata=a;
 887   1           xyje=1;Delay25us();
 888   1           xyje=0;
 889   1           TR1 = 1;
 890   1      }
 891          //函    数：xyjzm
 892          //功    能：写入字母到1602液晶屏固定位置
 893          //返回参数：无
 894          //输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,*s显示字符串 
 895          void xyjzm(ucd row,ucd  col , ucd *s){
 896   1          ucx i;
 897   1              if(row == 0) xyjml(0x80 + col);
 898   1              else if(row ==1 ) xyjml(0xc0 + col);
 899   1          i = 0;
 900   1          while(s[i] != '\0'){
 901   2              xyjsj(s[i]);
 902   2              i++;
 903   2          }
 904   1      }
 905          //函    数：xyjsz
 906          //功    能：写入数字到160液晶屏固定位置
 907          //返回参数：无
 908          //输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,count显示数字
 909          void xyjsz(ucd  row,ucd col , scd wei ,long count){
 910   1              while(wei != 0){
 911   2                      if(row == 0) xyjml(0x80 + col + wei--);
 912   2                      else if(row ==1 ) xyjml(0xc0 + col + wei--);
 913   2                      xyjsj(count % 10 + 48);
 914   2                      count /= 10;
 915   2              }
 916   1      }
 917          //函    数：xyjsz
 918          //功    能：写入符号到1602液晶屏固定位置
 919          //返回参数：无
 920          //输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,dat显示符号
 921          void xyjzzfh(ucd row ,ucd col,ucd dat){
 922   1              if(row == 0) xyjml(0x80 + col);
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 16  

 923   1                      else if(row ==1 ) xyjml(0xc0 + col);
 924   1              xyjsj(dat);
 925   1      }
 926          //函    数：xyjcsh
 927          //功    能：1602液晶屏初始化
 928          //返回参数：无
 929          //输入参数：无
 930          void xyjcsh()
 931          {       
 932   1              ucd i =0;
 933   1          xyje=0;
 934   1          xyjml(0x38);Delay50ms();
 935   1          xyjml(0x0c);Delay50ms();
 936   1          xyjml(0x06);Delay50ms();
 937   1          xyjml(0x01);Delay50ms();
 938   1          //自制字符写入
 939   1              xyjml(0x40);Delay50ms();
 940   1          for(i = 0;i<56;i++){
 941   2                      xyjsj(xyjfhz[i]);
 942   2              }
 943   1      }
 944          //-----------------------------------------------------------------------------------//
 945          //-----------------------------------------------------------------------------------//
 946          //                                  function end
 947          //-----------------------------------------------------------------------------------//
 948          //-----------------------------------------------------------------------------------//
 949          
 950          
 951          //===================================================================================//
 952          //===================================================================================//
 953          //                               function    4*4键盘
 954          //===================================================================================//
 955          //===================================================================================//
 956          #define jpca 1500
 957          #define jpda 1000
 958          #define jpdata P2
 959          ucx jpjz;
 960          ucd jpxh;
 961          uix jpsj;
 962          
 963          ucc jplie[4] = {0xfe,0xfd,0xfb,0xf7};
 964          ucc jpsao[] = {0xee,0xde,0xbe,0x7e,
 965                         0xed,0xdd,0xbd,0x7d,
 966                         0xeb,0xdb,0xbb,0x7b,
 967                         0xe7,0xd7,0xb7,0x77,
 968                        };
 969          ucd jphm(){
 970   1          ucx i,k = 16;
 971   1          jpdata = 0xf0;
 972   1          if(jpdata != 0xf0){
 973   2              if(jpxh ==7){
 974   3                  for(i = 0;i < 4 ; i++){
 975   4                      jpdata = jplie[i];
 976   4                      if(jpdata != jplie[i]){
 977   5                          k = jpdata;
 978   5                      }
 979   4                  }
 980   3              }
 981   2              jpxh++;
 982   2              if(jpxh > jpsj){
 983   3                  jpsj = jpca;
 984   3                  jpxh = 0;
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 17  

 985   3              }
 986   2          }
 987   1          else {
 988   2              jpxh = 0;
 989   2              jpsj = jpca;
 990   2          };
 991   1          return k;
 992   1      }
 993          void jpsm(){
 994   1          ucx i,j ;
 995   1          j = jphm();
 996   1          if(j!=16){
 997   2              for(i =0 ;i<16;i++){
 998   3                  if(jpsao[i] == j){
 999   4                      jpjz = i;
1000   4                  }
1001   3              }
1002   2          }
1003   1      }
1004          ucd jprun(){
1005   1          jpsm();
1006   1          if(jpxh ==7){
1007   2              jpsm();
1008   2              return jpjz;
1009   2          }
1010   1          return 16;
1011   1      }
1012          
1013          /*-----------------------------------------------------------------------------------*/
1014          /*-----------------------------------------------------------------------------------*/
1015          /*                                  function end
1016          /*-----------------------------------------------------------------------------------*/
1017          /*-----------------------------------------------------------------------------------*/
1018          
1019          
1020          /*===================================================================================*/
1021          /*===================================================================================*/
1022          /*                               function   直流电机
1023          /*===================================================================================*/
1024          /*功能：控制直流电机正反转以及停止等动作，
1025          /*===================================================================================*/
1026          //使用数据定义
1027          //空点，方向，运行，空点外  
1028          bit zlwei,zlfx,zlyx,zlout;
1029          //空点计数（到计数）
1030          char data zljs;
1031          //使用扩展模块输出使用
1032          ucx zldj;
1033          //电机3种状态
1034          #define zltz() zldj = 3
1035          #define zlfz() zldj = 2
1036          #define zlzz() zldj = 1
1037          //函    数：zlrun()
1038          //功    能：直流电机运行函数，放在主程序末端
1039          //返回参数：无
1040          //输入参数：无
1041          void zlrun(){
1042   1          //电动机运行
1043   1          if(zlyx){
1044   2              //直流电机动作控制部分
1045   2              if(zljs <= 0) {zltz();zljs = 0;}
1046   2              else {if(zlfx) zlzz(); else if(!zlfx) zlfz();};
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 18  

1047   2              //直流电机空点、计数处理部分
1048   2              if((zlout != 1)&&(zlwei == 1)) {zljs--;zlwei = 0;}
1049   2              if((zlout == 1)&&(zlwei == 0)) {zlwei = 1;}
1050   2          } 
1051   1          //电动机停止
1052   1          else zltz();
1053   1      }
1054          //函    数：zlsd()
1055          //功    能：电动机设置函数，使用时输入一下参数
1056          //返回参数：无
1057          //输入参数：fxz直流电运动机方向（0-~1),jsz直流电机需要旋转的空点数（0~255）)
1058          void zlsd(bit fx,ucd jsz){zlfx = fx; zljs = jsz;zlyx = 1;}
1059          //-----------------------------------------------------------------------------------//
1060          //-----------------------------------------------------------------------------------//
1061          //                                  function end
1062          //-----------------------------------------------------------------------------------//
1063          //-----------------------------------------------------------------------------------//
1064          
1065          //===================================================================================//
1066          //===================================================================================//
1067          //                               function   步进
1068          //===================================================================================//
1069          //===================================================================================//
1070          bit bjrl;
1071          bit bjdir ;
1072          sbit bjcp = P3^2;
1073          uix bjcsz = 764;
1074          ucd bjjs;
1075          static unsigned int bjjsz;
1076          static unsigned int bjsdz;
1077          
1078          void kzsc();
1079          void read165();
1080          bit bjyx;
1081          
1082          void bjfw(){
1083   1          bjcp = 1;bjjsz = 0;
1084   1          bjdir = 1;kzsc();//写方向方向与at89s52版本刚好相反
1085   1          //bjjsz =0;
1086   1          while(bjrl == 0){
1087   2              Delay25us();Delay25us();Delay25us();;
1088   2              read165();
1089   2              while(bjrl == 0){
1090   3                  bjcp =1;Delay25us();
1091   3                  bjcp = 0;Delay25us();
1092   3                  read165();
1093   3                  //xyjsz(1,8,7,bjjsz++);
1094   3              }
1095   2          }
1096   1          
1097   1          
1098   1          bjdir = 0;kzsc();
1099   1          while(bjcsz > 0){
1100   2              bjcp =1;Delay25us();Delay25us();;
1101   2              bjcp = 0;Delay25us();Delay25us();;
1102   2              read165();
1103   2              bjcsz--;
1104   2          }
1105   1          
1106   1          bjjsz = 0;
1107   1          bjyx = 0;
1108   1          bjsdz = 0;
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 19  

1109   1      }
1110          
1111          void bjsd(ucd set){
1112   1          bjsdz = set *1370;
1113   1          if(bjsdz > bjjsz) {bjdir =0 ;bjyx = 1;};
1114   1          if(bjsdz < bjjsz) {bjdir = 1; bjyx = 1;};
1115   1          kzsc();//写方向方向与at89s52版本刚好相反
1116   1      }
1117          
1118          void bjrun(){
1119   1          if(bjjs++ > 1)
1120   1          {
1121   2              bjcp = 1;
1122   2              if(bjyx ==1 ){
1123   3                  bjcp = 0;
1124   3                  if(bjdir) bjjsz--;else bjjsz++;
1125   3                  if(bjjsz == bjsdz) bjyx = 0;
1126   3              }
1127   2              bjjs = 0;
1128   2          }
1129   1      }
1130          
1131          //-----------------------------------------------------------------------------------//
1132          //-----------------------------------------------------------------------------------//
1133          //                                  function end
1134          //-----------------------------------------------------------------------------------//
1135          //-----------------------------------------------------------------------------------/
1136          
1137          //===================================================================================//
1138          //===================================================================================//
1139          //                               function    机械手
1140          //===================================================================================//
1141          //===================================================================================//
1142          
1143          
1144          ucd jxsdj;//输出
1145          ucd jxssr;//输入
1146          ucd jxszt;
1147          ucx jxsq1,jxsq2;
1148          ucd jxswz;
1149          static ucd jxsdzz[8];
1150          bit jxsyx;
1151          
1152          #define jxszy  1
1153          #define jxsyy  2
1154          #define jxsjf  4
1155          #define jxssj  8
1156          
1157          #define jxsgw1 jxssr&0x01
1158          #define jxsgw2 jxssr&0x02
1159          #define jxsgw3 jxssr&0x04
1160          #define jxsxx  jxssr&0x08
1161          #define jxsjj  jxssr&0x10
1162          #define jxsgq  jxssr&0x20
1163          #define jxsgd1 jxssr&0x40
1164          #define jxsgd2 jxssr&0x80
1165          
1166          bit jxsdz(ucd dz){
1167   1          bit zt = 0;
1168   1          switch(dz){
1169   2              case 0:{};break;
1170   2              case 1:{
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 20  

1171   3                  if(jxsgw3) jxsdj &= ~jxszy ; 
1172   3                  else {jxsdj |= jxszy ;zt = 1;}
1173   3              };break;
1174   2              case 2:{
1175   3                  if(jxsgw2) jxsdj &= ~jxszy ;
1176   3                  else { jxsdj |= jxszy ;zt = 1;}
1177   3              };break;
1178   2              case 3:{
1179   3                  if(jxsgw1) jxsdj &= ~jxsyy;
1180   3                  else { jxsdj |= jxsyy ;zt = 1;}
1181   3              };break;
1182   2              case 4:{
1183   3                  if(jxsgw2)   jxsdj &= ~jxsyy;
1184   3                  else { jxsdj |= jxsyy;zt = 1;}
1185   3              };break;
1186   2              case 5:{};break;
1187   2              case 6:{};break;
1188   2              case 7:{};break;
1189   2              case 8:{};break;
1190   2              case 9:{};break;
1191   2          }
1192   1          return zt;
1193   1      }
1194          
1195          bit jxssd(long  dz){
1196   1          bit zt = 0;
1197   1          char i ;
1198   1          if(jxswz > 7){
1199   2              for(i = 7; i>0 ;i--){
1200   3                  jxsdzz[i] = 0;
1201   3                  jxsdzz[i] = dz%10;
1202   3                  dz /= 10;
1203   3              }
1204   2              zt = 1;
1205   2              jxswz = 0;
1206   2          }
1207   1          return zt;
1208   1      }
1209          
1210          jxsrun(){
1211   1          if(jxsyx){
1212   2              if(jxswz < 8){
1213   3                  if(jxsdz(jxsdzz[jxswz]))
1214   3                      jxswz++;
1215   3              }
1216   2          }
1217   1          //else {jxsdj &= ~((jxszy + jxsyy)<<4);};
1218   1      }
1219          
1220          void jxsfw(){
1221   1          jxswz = 9;
1222   1          jxssd(1);
1223   1          while(jxswz < 8){
1224   2              jxsrun();
1225   2          }
1226   1      }
1227          //-----------------------------------------------------------------------------------//
1228          //-----------------------------------------------------------------------------------//
1229          //                                  function end
1230          //-----------------------------------------------------------------------------------//
1231          
1232          
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 21  

1233          //===================================================================================//
1234          //===================================================================================//
1235          //                               function   74ls165
1236          //===================================================================================//
1237          //===================================================================================//
1238          sbit QH = P3^3;
1239          sbit CLK  = P3^5;
1240          sbit SL =   P3^4;
1241          uid kzxh,kzdata;
1242          
1243          void read165(){
1244   1          
1245   1          ncx i;
1246   1          SL = 0;
1247   1          kzxh = 0;Delay25us();
1248   1          SL = 1;
1249   1          for(i = 10; i > 0;i--){
1250   2              CLK = 0;Delay25us();
1251   2              kzxh <<= 1;
1252   2              if(QH) kzxh |= 0X01;
1253   2              CLK = 1;
1254   2              
1255   2          }
1256   1          if(kzdata != kzxh) {
1257   2              kzdata = kzxh;
1258   2              jxssr = (unsigned char )kzdata >> 2;
1259   2              bjrl =   kzdata  & 0x01;
1260   2              zlout =   kzdata & 0x02;//djmsz(2,100,zlout,1,0);
1261   2          }
1262   1      }
1263          
1264          
1265          //===================================================================================//
1266          //===================================================================================//
1267          //                               function    74hc595
1268          //===================================================================================//
1269          //===================================================================================//
1270          sbit hc595_ds   = P3^7;
1271          sbit hc595_stcp = P3^6;
1272          sbit hc595_shcp = P3^5;
1273          
1274          ucx kzsj;
1275          void kzsc(){
1276   1          ucd i;
1277   1          ucd j = jxsdj<<4 | zldj<<2 | bjdir ;
1278   1          if(kzsj !=  j){
1279   2              for(i= 0; i<8;i++){
1280   3                  hc595_shcp  = 0;
1281   3                  hc595_ds    = j & (0x80 >> i);
1282   3                  hc595_shcp  = 1;
1283   3              }
1284   2              hc595_stcp = 0;Delay25us();
1285   2              hc595_stcp = 1;
1286   2          }
1287   1          kzsj = j;
1288   1      }
1289          //-----------------------------------------------------------------------------------//
1290          //-----------------------------------------------------------------------------------//
1291          //                                  function end
1292          //-----------------------------------------------------------------------------------//
1293          //-----------------------------------------------------------------------------------//
1294          
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 22  

1295          
1296          //===================================================================================//
1297          //===================================================================================//
1298          //                              subjust 
1299          //===================================================================================//
1300          //===================================================================================//
1301          
1302          
1303          void main()
1304          {
1305   1          ucd ABC;
1306   1          ucd key;
1307   1          P0M0 = 0xFF;
1308   1          P0M1 = 0X00;
1309   1          P1M0 = 0x00;
1310   1          P1M1 = 0x00;
1311   1          P2M0 = 0x00;
1312   1          P2M1 = 0x00;
1313   1          P3M0 = 0xFF;
1314   1          P3M1 = 0x00;
1315   1          P4M0 = 0x00;//2F
1316   1          P4M1 = 0x00;
1317   1          P5M0 = 0x00;//20
1318   1          P5M1 = 0x00;
1319   1          P6M0 = 0x00;
1320   1          P6M1 = 0x00;
1321   1          P7M0 = 0x00;
1322   1          P7M1 = 0x00;
1323   1      
1324   1      
1325   1          xyjcsh();
1326   1          dyjcsh(0,8);
1327   1          
1328   1          
1329   1          AUXR = 0;
1330   1          initt1();
1331   1          SCON = 0x50;                //8位可变波特
1332   1          T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
1333   1          T2H = (65536 - (FOSC/4/BAUD))>>8;
1334   1          AUXR |= 0x14; 
1335   1          AUXR |= 0x01;               //此处AUXR必须分两次赋值
1336   1          ES = 1; 
1337   1          
1338   1          EA  = 1;
1339   1          //InitADC();
1340   1          //hc595_write (0); hc595_write (0xFF);
1341   1                     
1342   1                           //初始化ADC
1343   1          //SendString("STC15F2K60S2\r\nUart Test !\r\n");
1344   1          smgdps(3);
1345   1          zldj = 0x03;
1346   1          jxsdj = 0x0f;
1347   1          xyjcsh();
1348   1          xyjsz(1,7,5,789);
1349   1          //smgxhc(0,4,124);
1350   1          //smgxhc(1,4,12);
1351   1          //bjrl = 1;
1352   1          read165();
1353   1          bjfw();
1354   1          bjjs = 0;
1355   1          //jxsfw();
1356   1          while (1){
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 23  

1357   2                               
1358   2              unsigned char xdata i;
1359   2              //smgxhc(0,8,12345678);
1360   2                                //smgrun();
1361   2              key = jprun();
1362   2              /*GetADCResult();
1363   2              P3 = 0;
1364   2         
1365   2              for( i = 0; i < 8 ;i++)
1366   2              {
1367   2                  djmsz(0,i*16,jxsdzz[i],1,i%2);
1368   2              }
1369   2              */
1370   2              
1371   2              //i = kzdata & 0X03;
1372   2              //djmsz(4,0,i,3,0);
1373   2              //i = kzdata>>2;
1374   2              //djmsz(4,32,i,3,0);
1375   2      
1376   2              //djmsz(6,0,kzxh,7,0);
1377   2              
1378   2              //xyjsz(0,0,1,zlout);
1379   2              //xyjsz(0,4,1,zlwei);
1380   2              
1381   2              //xyjzzfh(1,0,up);
1382   2              //xyjzm(1,5,"blue");
1383   2              if(key != 16) djmsz(4,72,key,3,0);
1384   2              //djmsz(4,72,zldj,3,0);
1385   2              djmsz(6,72,ABC++,3,0);
1386   2              //smgrun();
1387   2        
1388   2              //str(1,12,"fx:");
1389   2      
1390   2              //djmsz(2, 0,count,5,0);
1391   2              //djmsz(2, 0,"白",3,0);
1392   2              //djmsz(4, 0,dyj32[1],3,0);
1393   2              //djmsz(2,0,"白",6,0);
1394   2              //djmzm(0,0,"HELLO",0);
1395   2              
1396   2              //djmhz(4,0,"两岸猿声啼不住，",0);
1397   2              //djmhz(6,0,"轻舟已过万重山：",0);
1398   2              //dyjsz(4,0,10,0);
1399   2              //dyjhz(6,63,"日",0);
1400   2              //djmzm(4,0,"h e l l o w",0);
1401   2                                      //if(key != 16){
1402   2                                      //      xyjsz(1,8,7,key);
1403   2                                      //      djmhz(0,0,"朝辞白帝彩云间，",0);
1404   2                                      //      djmhz(2,0,"千里江陵一日还。",1);
1405   2                                      //}
1406   2              
1407   2              //Delay50ms();
1408   2             
1409   2              //smgxhc(0,4,GetADCResult(7));
1410   2              //smgdps(3);
1411   2              
1412   2              
1413   2             /*
1414   2              if(key != 16){
1415   2                  smgxhc(0,4,key);
1416   2                  //djmsz(2,0,key,2,1);
1417   2                  zlsd(0,key);
1418   2                  //bjsd(key);
C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 24  

1419   2                  /*
1420   2                  switch(key){
1421   2                      //case  1:{zldj=0; zldj = 1;}break;
1422   2                      //case  2:{zldj=0; zldj = 2;}break;
1423   2                      //case  3:{zldj=3 ;           }break;
1424   2                      case  4:{jxsdj |= 1;}break;
1425   2                      case  5:{jxsdj |= 2;}break;
1426   2                      case  6:{jxsdj |= 4;}break;
1427   2                      case  7:{jxsdj |= 8;}break;
1428   2                      case  8:{jxsdj &= 0x0e;}break;
1429   2                      case  9:{jxsdj &= 0x0d;}break;
1430   2                      case 10:{jxsdj &= 0x0b;}break;
1431   2                      case 11:{jxsdj &= 0x07;}break;
1432   2                  }   
1433   2                  if(key == 3) jxssd(3);
1434   2                  if(key == 1) jxssd(4);
1435   2                  if(key == 2) jxssd(2);
1436   2                  if(key == 4) jxssd(1);
1437   2              }
1438   2              */
1439   2              //smgxhc(0,4,1);
1440   2              smgxhc(4,4,ABC);
1441   2              //xyjsz(0,7,5,ABC);
1442   2                      //smgxhc(4,4,0000);
1443   2              /*
1444   2              xyjsz(0,7,5,adz);
1445   2              {
1446   2                  bjsd(adz/17);
1447   2              }
1448   2              //xyjsz(1,7,5,adjs);
1449   2              */
1450   2              //smgxhc(0,4,bjsdz);
1451   2              //smgxhc(4,4,bjjsz);
1452   2              //xyjsz(1,1,3,adjs);
1453   2              //SendData(count);
1454   2              //xyjsz(1,6,1,(ucd)bjrl);
1455   2              //xyjsz(1,8,7,bjsdz);
1456   2              
1457   2              //djmsz(4,20,jxssr,5,1);
1458   2              
1459   2              
1460   2              //zlsd(0,key);
1461   2              //read165();
1462   2              //zlrun();
1463   2              //kzsc();
1464   2              //hc595_write (jxsdj<<4 | zldj<<2);
1465   2              //kzsc(jxsdj<<4 | zldj<<2);
1466   2              //hc595_write(count);
1467   2              //SendString("STC15F2K60S2\r\nUart Test !\r\n");
1468   2              //bjrun();
1469   2              //jxsrun();
1470   2              }
1471   1      }
*** WARNING C280 IN LINE 1358 OF No.2.c: 'i': unreferenced local variable
1472          //-----------------------------------------------------------------------------------//
1473          //-----------------------------------------------------------------------------------//
1474          //                                 subjust end
1475          //-----------------------------------------------------------------------------------//
1476          //-----------------------------------------------------------------------------------//
*** WARNING C290 IN LINE 1218 OF No.2.c: missing return value


C51 COMPILER V9.52.0.0   NO_2                                                              08/04/2018 15:40:56 PAGE 25  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2485    ----
   CONSTANT SIZE    =   2202    ----
   XDATA SIZE       =     65       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     35      60
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      9      10
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  2 WARNING(S),  0 ERROR(S)
