/*---------------------------------------------------------------------*/
/* --- STC MCU Limited ------------------------------------------------*/
/* --- STC15F4K60S4 系列 定时器1的16位自动重装载模式举例---------------*/
/* --- Mobile: (86)13922805190 -------------- -------------------------*/
/* --- Fax: 86-0513-55012956,55012947,55012969 ------------------------*/
/* --- Tel: 86-0513-55012928,55012929,55012966-------------------------*/
/* --- Web: www.STCMCU.com --------------------------------------------*/
/* --- Web: www.GXWMCU.com --------------------------------------------*/
/* 如果要在程序中使用此代码,请在程序中注明使用了STC的资料及程序        */
/* 如果要在文章中应用此代码,请在文章中注明使用了STC的资料及程序        */
/*---------------------------------------------------------------------*/

//本示例在Keil开发环境下请选择Intel的8058芯片型号进行编译
//若无特别说明,工作频率一般为11.0592MHz


#include "reg51.h"

#include "intrins.h"

typedef unsigned char BYTE;
typedef unsigned int WORD;

#define scd char 
#define ucd unsigned char 
#define ucx unsigned char xdata
#define ucc unsigned char code
#define ncx signed char xdata
#define sid int 
#define uid unsigned int data
#define uix unsigned int xdata

//-----------------------------------------------

#define FOSC 11059200L          //系统频率
#define BAUD 115200             //串口波特率

#define NONE_PARITY     0       //无校验
#define ODD_PARITY      1       //奇校验
#define EVEN_PARITY     2       //偶校验
#define MARK_PARITY     3       //标记校验
#define SPACE_PARITY    4       //空白校验

#define PARITYBIT EVEN_PARITY   //定义校验位


sfr P0M1 = 0x93;
sfr P0M0 = 0x94;
sfr P1M1 = 0x91;
sfr P1M0 = 0x92;
sfr P2M1 = 0x95;
sfr P2M0 = 0x96;
sfr P3M1 = 0xb1;
sfr P3M0 = 0xb2;
sfr P4M1 = 0xb3;
sfr P4M0 = 0xb4;
sfr P5M1 = 0xC9;
sfr P5M0 = 0xCA;
sfr P6M1 = 0xCB;
sfr P6M0 = 0xCC;
sfr P7M1 = 0xE1;
sfr P7M0 = 0xE2;
sfr P4   = 0xc0;
sfr AUXR = 0x8e;                    //Auxiliary register




bit busy;


sfr P_SW1   = 0xA2;             //外设功能切换寄存器1

#define S1_S0 0x40              //P_SW1.6
#define S1_S1 0x80              //P_SW1.7
void SendData(BYTE dat);
void SendString(char *s);

/////定时器2
sfr IE2       = 0xaf;               //中断使能寄存器2
sfr T2H       = 0xD6;               //定时器2高8位
sfr T2L       = 0xD7;               //定时器2低8位
/////


unsigned int count_nei;


//===================================================================================//
//===================================================================================//
//                               function    串口中断
//===================================================================================//
//===================================================================================//

//sfr  AUXR       =   0x8e;       //辅助寄存器                              
/*
sfr ADC_CONTR   =   0xBC;           //ADC控制寄存器
sfr ADC_RES     =   0xBD;           //ADC高8位结果
sfr ADC_RESL     =   0xBE;           //ADC高8位结果
sfr ADC_LOW2    =   0xBE;           //ADC低2位结果
sfr P1ASF       =   0x9D;           //P1口第2功能控制寄存器
sfr CLK_DIV     =   0X97;

#define ADC_POWER   0x80            //ADC电源控制位
#define ADC_FLAG    0x10            //ADC完成标志
#define ADC_START   0x08            //ADC起始控制位
#define ADC_SPEEDLL 0x00            //540个时钟
#define ADC_SPEEDL  0x20            //360个时钟
#define ADC_SPEEDH  0x40            //180个时钟
#define ADC_SPEEDHH 0x60            //90个时钟
*/

/*----------------------------
软件延时
----------------------------*/
void Delay(WORD n)
{
    WORD x;

    while (n--)
    {
        x = 5000;
        while (x--);
    }
}

/*----------------------------*/
//读取ADC结果
/*
#define ads 1
int adz;
void GetADCResult()
{
    if(ADC_CONTR & ADC_FLAG){
        ADC_CONTR &= ~ADC_FLAG; 
        adz =  ADC_RES;
        ADC_CONTR = ADC_POWER | 0 | ADC_START |ADC_SPEEDHH; 
    }
}
*/

/*----------------------------
初始化ADC
----------------------------*/
/*
void InitADC()
{
    P1ASF = 0x01;                   //设置 C口为AD口
    ADC_RES = 0;                    //清除结果寄存器
    ADC_CONTR = ADC_POWER | ADC_SPEEDLL | 0 | ADC_START;
    Delay(2);                       //ADC上电并延时
}
*/
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//

//===================================================================================//
//===================================================================================//
//                               function    串口中断
//===================================================================================//
//===================================================================================//
/*-------------------------------------------smg 函数开始--------------------------------------------*/
//                                                                                                  //
//                                                                                                  //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//使用引脚定义
#define smgdata P0
/*
sbit smgcs1 = P1^0;
sbit smgcs2 = P1^1;
sbit smgwr  = P1^2;
*/
sbit smgcs1 = P1^2;
sbit smgcs2 = P1^1;
sbit smgwr  = P1^3;
//使用数据定义
static scd smgb;
ucd smgdp;
ucd smghc[8] ;
unsigned char code smgdm[] = {0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90,0x88,0x83,0xc6,0xa1,0x86,0x8e,0xff};
//小数点函数
#define smgdps(x) smgdp |= 0x80 >> x            //小数点置位
#define smgdpr(x) smgdp &= ~（0x80 >> x ）      //清楚某位小数点
#define smgdpc(x) smgdp = 0;                    //清楚所有小数点
//函    数：smgxhc
//功    能：将数字写入数码管缓存中
//返回参数：无
//输入参数：wz显示数字的起始位置，cd连续显示多少位，sz显示数据内容
void smgxhc(unsigned char wz,unsigned char cd,unsigned int sz){
	char i ;
    TR1 = 0;
	for(i  = cd - 1 ;i >= 0 ; i--){
		smghc[wz + i ] = sz % 10;
		sz = sz /10;
	}	
/*	
    i = 0;
	while(smghc[wz + i] == 0){
		if(i == cd -1 )break;
		smghc[wz + i ] = 16;
		i++;
	}*/
    TR1 = 1;
}
//函    数：smgrun
//功    能：数码管运行函数，通常放在定时器中
//返回参数：无
//输入参数：无
void smgrun(){
    ucd i ;
	smgb += 1 ;
	smgb = smgb & 0x07;
	
	smgcs1 = smgwr = 0;
	smgdata = 0xff;
	smgcs1 = smgwr = 1;

	smgcs2 = smgwr = 0;;
    smgdata = _cror_(0x7f,smgb);
	smgcs2 = smgwr = 1;

	smgcs1 = smgwr = 0;
    i = smgdp & _cror_(0x80,smgb);
    if(i !=0)
        smgdata = smgdm[smghc[smgb]]  & 0x7f;
    else smgdata = smgdm[smghc[smgb]];
	smgcs1 = smgwr = 1;
	

}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//



//===================================================================================//
//===================================================================================//
//                               function    串口中断
//===================================================================================//
//===================================================================================//
void bjrun();
//函    数：tm1_isr
//功    能：定时器T1中断程序
//返回参数：无
//输入参数：无
void tm1_isr() interrupt 3 using 1  
{
    smgrun();
    bjrun();
}
//函    数：initt1
//功    能：定时器T1复位，11.0592MHz情况下，100微秒，12T，误差0.17%，16位自动重载模式
//返回参数：无
//输入参数：无
void initt1(){
    AUXR &= 0xBF;   //定时器时钟12T模式
	TMOD &= 0x0F;	//设置定时器模式
	TL1 = 0xA4;		//设置定时初值
	TH1 = 0xFF;		//设置定时初值
	TF1 = 0;		//清除TF1标志
	TR1 = 1;		//定时器1开始计时
    ET1 = 1;        //使能定时器1中断
}

//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//


/*定时中断1 函数结束----------------------------------------------------------------------------------*/

void Delay25us()		//@11.0592MHz
{
	ucd i;

	_nop_();
	_nop_();
	i = 66;
	while (--i);
}


void Delay50ms()		//@11.0592MHz
{
	unsigned char i, j, k;

	_nop_();
	_nop_();
	i = 3;
	j = 26;
	k = 223;
	do
	{
		do
		{
			while (--k);
		} while (--j);
	} while (--i);
}

//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//

//===================================================================================//
//===================================================================================//
//                               function    串口中断
//===================================================================================//
//===================================================================================//

/*128液晶 函数开始-----------------------------------------------------------------------------------*/
//                                                                                                  //
//                                                                                                  //
//                                                                                                  //
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////
#define dyjdata P0
sbit dyjcs2 =  P1^4;
sbit dyjcs1 =  P1^5;
sbit dyje   =  P1^6;
sbit dyjrs  =  P1^7;



code unsigned char dyj32[][32] = {
//-- 朝 --
      0x00,0xE4,0xA4,0xA4,0xBF,0xA4,0xA6,0xF4,
      0x20,0xFE,0x22,0x22,0x22,0xFF,0x02,0x00,
      0x10,0x17,0x12,0x12,0xFE,0x12,0x1A,0x93,
      0x40,0x3F,0x02,0x42,0x82,0x7F,0x00,0x00,
//-- 辞 --
      0x44,0x44,0x44,0xFE,0x43,0x62,0x40,0x08,
      0x28,0x49,0x0E,0x48,0x2C,0x88,0x00,0x00,
      0x00,0xFE,0x42,0x43,0x42,0xFF,0x02,0x09,
      0x09,0x09,0xFF,0x09,0x0D,0x09,0x01,0x00,
//-- 白 --
      0x00,0x00,0xF8,0x08,0x0C,0x0A,0x09,0x08,
      0x08,0x08,0x08,0x08,0xFC,0x08,0x00,0x00,
      0x00,0x00,0x7F,0x21,0x21,0x21,0x21,0x21,
      0x21,0x21,0x21,0x21,0x7F,0x00,0x00,0x00,
//-- 帝 --
      0x80,0x60,0x24,0x24,0x2C,0x34,0x25,0xE6,
      0x24,0x34,0x2C,0xA6,0x24,0xA0,0x60,0x00,
      0x00,0x00,0x00,0x3F,0x01,0x01,0x01,0xFF,
      0x01,0x11,0x21,0x1F,0x01,0x00,0x00,0x00,
//-- 彩 --
      0x84,0x8C,0xB4,0x84,0xDA,0x82,0x92,0x8D,
      0x20,0x10,0x08,0x84,0x46,0x60,0x00,0x00,
      0x20,0x10,0x08,0x06,0xFF,0x02,0x04,0x0C,
      0x80,0x42,0x21,0x10,0x08,0x0C,0x00,0x00,
//-- 云 --
      0x40,0x40,0x40,0x44,0x44,0x44,0xC4,0x44,
      0x44,0x44,0x46,0x44,0x40,0x60,0x40,0x00,
      0x00,0x00,0x40,0x60,0x58,0x46,0x41,0x40,
      0x40,0x40,0x50,0x60,0xC0,0x00,0x00,0x00,
//-- 间 --
      0x00,0xF8,0x01,0x02,0xF6,0x10,0x12,0x12,
      0x12,0x12,0xFA,0x12,0x02,0xFF,0x02,0x00,
      0x00,0xFF,0x00,0x00,0x3F,0x11,0x11,0x11,
      0x11,0x11,0x3F,0x40,0x80,0x7F,0x00,0x00,
//-- 千 --
      0x80,0x80,0x84,0x84,0x84,0x84,0x84,0xFC,
      0x82,0x82,0x83,0x82,0x80,0xC0,0x80,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//-- 里 --
      0x00,0x00,0xFE,0x12,0x12,0x12,0x12,0xFE,
      0x12,0x12,0x12,0x12,0xFF,0x02,0x00,0x00,
      0x40,0x48,0x49,0x49,0x49,0x49,0x49,0x7F,
      0x49,0x49,0x49,0x49,0x4D,0x68,0x40,0x00,
//-- 江 --
      0x10,0x21,0x62,0x06,0x80,0x04,0x04,0x04,
      0x04,0xFC,0x04,0x04,0x06,0x04,0x00,0x00,
      0x04,0x04,0xFE,0x01,0x20,0x20,0x20,0x20,
      0x20,0x3F,0x20,0x20,0x20,0x30,0x20,0x00,
//-- 陵 --
      0x00,0xFE,0x02,0x22,0xDA,0x06,0x20,0xA4,
      0x64,0xA4,0x3F,0x24,0x66,0xB4,0x20,0x00,
      0x00,0xFF,0x08,0x10,0x08,0x87,0x89,0x44,
      0x46,0x29,0x11,0x29,0x47,0xC0,0x41,0x00,
//-- 一 --
      0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
      0x80,0x80,0x80,0x80,0x80,0xC0,0x80,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
//-- 日 --
      0x00,0x00,0x00,0xFE,0x82,0x82,0x82,0x82,
      0x82,0x82,0x82,0xFF,0x02,0x00,0x00,0x00,
      0x00,0x00,0x00,0x7F,0x20,0x20,0x20,0x20,
      0x20,0x20,0x20,0x7F,0x00,0x00,0x00,0x00,
//-- 还 --
      0x20,0x22,0xEC,0x00,0x04,0x04,0x04,0x84,
      0xE4,0x1C,0x84,0x04,0x04,0x06,0x04,0x00,
      0x40,0x20,0x1F,0x20,0x44,0x42,0x41,0x40,
      0x5F,0x40,0x40,0x41,0x43,0x66,0x20,0x00,
//-- 两 --
      0x02,0xF2,0x12,0x12,0x12,0xFE,0x12,0x12,
      0x12,0xFE,0x12,0x12,0x12,0xFB,0x12,0x00,
      0x00,0xFF,0x10,0x08,0x04,0x03,0x14,0x08,
      0x04,0x03,0x04,0x48,0x98,0x7F,0x00,0x00,
//-- 岸 --
      0x00,0x00,0xEE,0x28,0xA8,0xA8,0xA8,0xAF,
      0xA8,0xA8,0xA8,0xE8,0xAE,0x20,0x00,0x00,
      0x40,0x20,0x1F,0x04,0x04,0x04,0x04,0x04,
      0xFF,0x04,0x04,0x04,0x06,0x04,0x00,0x00,
//-- 猿 --
      0x40,0x22,0x14,0x08,0xF4,0x12,0xD5,0x54,
      0x54,0x5F,0x54,0x54,0xF6,0x54,0x10,0x00,
      0x08,0x44,0x82,0x41,0x3F,0x20,0x13,0xFE,
      0x42,0x26,0x0A,0x12,0x2B,0x64,0x20,0x00,
//-- 声 --
      0x04,0x14,0xD4,0x54,0x54,0x54,0x54,0xDF,
      0x54,0x54,0x54,0x54,0xF4,0x56,0x04,0x00,
      0x80,0x60,0x1F,0x02,0x02,0x02,0x02,0x03,
      0x02,0x02,0x02,0x02,0x07,0x00,0x00,0x00,
//-- 啼 --
      0x00,0xFC,0x04,0x04,0xFE,0x84,0x60,0x24,
      0x2C,0x35,0xE6,0x34,0x2C,0xA4,0x60,0x00,
      0x00,0x1F,0x08,0x08,0x1F,0x00,0x00,0x3F,
      0x01,0x01,0xFF,0x01,0x21,0x3F,0x01,0x00,
//-- 不 --
      0x02,0x02,0x02,0x02,0x02,0x82,0x42,0xF2,
      0x0E,0x42,0x82,0x02,0x02,0x03,0x02,0x00,
      0x00,0x08,0x04,0x02,0x01,0x00,0x00,0xFF,
      0x00,0x00,0x00,0x01,0x03,0x06,0x00,0x00,
//-- 住 --
      0x80,0x40,0x20,0xF8,0x07,0x08,0x08,0x08,
      0x09,0xFE,0x08,0x08,0x88,0x0C,0x08,0x00,
      0x00,0x00,0x00,0xFF,0x40,0x41,0x41,0x41,
      0x41,0x7F,0x41,0x41,0x41,0x61,0x40,0x00,
//-- 轻 --
      0x08,0xC8,0xB8,0x8F,0xE8,0x8C,0x48,0x42,
      0x22,0x22,0x12,0x1A,0x36,0x22,0x40,0x00,
      0x08,0x18,0x08,0x08,0xFF,0x04,0x44,0x42,
      0x42,0x42,0x7E,0x42,0x43,0x62,0x40,0x00,
//-- 舟 --
      0x80,0x80,0x80,0xFC,0x84,0x86,0x95,0xE4,
      0x84,0x84,0x84,0xFE,0x84,0xC0,0x80,0x00,
      0x00,0x40,0x20,0x1F,0x00,0x00,0x02,0x0C,
      0x00,0x40,0x80,0x7F,0x00,0x00,0x00,0x00,
//-- 已 --
      0x00,0x02,0xF2,0x42,0x42,0x42,0x42,0x42,
      0x42,0x42,0x42,0xFF,0x02,0x00,0x00,0x00,
      0x00,0x00,0x3F,0x40,0x40,0x40,0x40,0x40,
      0x40,0x40,0x40,0x40,0x40,0x78,0x00,0x00,
//-- 过 --
      0x40,0x42,0x44,0xC8,0x00,0x08,0x08,0x48,
      0x88,0x08,0x08,0xFF,0x08,0x08,0x00,0x00,
      0x00,0x40,0x20,0x1F,0x20,0x40,0x40,0x40,
      0x41,0x48,0x50,0x4F,0x40,0x60,0x20,0x00,
//-- 万 --
      0x04,0x04,0x04,0x04,0x04,0x04,0xFC,0x44,
      0x44,0x44,0x44,0xE4,0x44,0x06,0x04,0x00,
      0x00,0x80,0x40,0x20,0x10,0x0E,0x01,0x00,
      0x40,0x80,0x40,0x3F,0x00,0x00,0x00,0x00,
//-- 重 --
      0x08,0x08,0x0A,0xEA,0xAA,0xAA,0xAA,0xFE,
      0xAA,0xAA,0xA9,0xF9,0x29,0x0C,0x08,0x00,
      0x40,0x40,0x48,0x4B,0x4A,0x4A,0x4A,0x7F,
      0x4A,0x4A,0x4A,0x4B,0x48,0x60,0x40,0x00,
//-- 山 --
      0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0xFF,
      0x00,0x00,0x00,0x00,0x00,0xF0,0x00,0x00,
      0x00,0x7F,0x20,0x20,0x20,0x20,0x20,0x3F,
      0x20,0x20,0x20,0x20,0x20,0x7F,0x00,0x00,

//-- ： --
      0x00,0x00,0x00,0x00,0x80,0xC0,0xC0,0x80,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x31,0x7B,0x7B,0x31,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      
//     "，",
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x46,0x2F,0x1F,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

//"。", 
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x38,0x7C,0x44,0x44,0x7C,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

code unsigned char   *dyjhzz = "朝辞白帝彩云间千里江陵一日还两岸猿声啼不住轻舟已过万重山：，。 ";

code unsigned char dyj16[][16] ={
    0xF8,0xFC,0x04,0xC4,0x24,0xFC,0xF8,0x00,0x07,0x0F,0x09,0x08,0x08,0x0F,0x07,0x00,  // -0-
	
	0x00,0x10,0x18,0xFC,0xFC,0x00,0x00,0x00,0x00,0x08,0x08,0x0F,0x0F,0x08,0x08,0x00,  // -1-
	
	0x08,0x0C,0x84,0xC4,0x64,0x3C,0x18,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0C,0x00,  // -2-

	0x08,0x0C,0x44,0x44,0x44,0xFC,0xB8,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,  // -3-
	
	0xC0,0xE0,0xB0,0x98,0xFC,0xFC,0x80,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,  // -4-

	0x7C,0x7C,0x44,0x44,0xC4,0xC4,0x84,0x00,0x04,0x0C,0x08,0x08,0x08,0x0F,0x07,0x00,  // -5-

	0xF0,0xF8,0x4C,0x44,0x44,0xC0,0x80,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,  // -6-

	0x0C,0x0C,0x04,0x84,0xC4,0x7C,0x3C,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,  // -7-

	0xB8,0xFC,0x44,0x44,0x44,0xFC,0xB8,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00,  // -8-

	0x38,0x7C,0x44,0x44,0x44,0xFC,0xF8,0x00,0x00,0x08,0x08,0x08,0x0C,0x07,0x03,0x00,  // -9-

    0xE0,0xF0,0x98,0x8C,0x98,0xF0,0xE0,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -A-

	0x04,0xFC,0xFC,0x44,0x44,0xFC,0xB8,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0F,0x07,0x00, // -B-

	0xF0,0xF8,0x0C,0x04,0x04,0x0C,0x18,0x00,0x03,0x07,0x0C,0x08,0x08,0x0C,0x06,0x00, // -C-

	0x04,0xFC,0xFC,0x04,0x0C,0xF8,0xF0,0x00,0x08,0x0F,0x0F,0x08,0x0C,0x07,0x03,0x00, // -D-

	0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00, // -E-

	0x04,0xFC,0xFC,0x44,0xE4,0x0C,0x1C,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -F-

	0xF0,0xF8,0x0C,0x84,0x84,0x8C,0x98,0x00,0x03,0x07,0x0C,0x08,0x08,0x07,0x0F,0x00, // -G-

	0xFC,0xFC,0x40,0x40,0x40,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -H-

	0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -I-

	0x00,0x00,0x00,0x04,0xFC,0xFC,0x04,0x00,0x07,0x0F,0x08,0x08,0x0F,0x07,0x00,0x00, // -J-

	0x04,0xFC,0xFC,0xC0,0xF0,0x3C,0x0C,0x00,0x08,0x0F,0x0F,0x00,0x01,0x0F,0x0E,0x00, // -K-

	0x04,0xFC,0xFC,0x04,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x08,0x0C,0x0E,0x00, // -L-

	0xFC,0xFC,0x38,0x70,0x38,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -M-

	0xFC,0xFC,0x38,0x70,0xE0,0xFC,0xFC,0x00,0x0F,0x0F,0x00,0x00,0x00,0x0F,0x0F,0x00, // -N-

	0xF0,0xF8,0x0C,0x04,0x0C,0xF8,0xF0,0x00,0x03,0x07,0x0C,0x08,0x0C,0x07,0x03,0x00, // -O-

	0x04,0xFC,0xFC,0x44,0x44,0x7C,0x38,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -P-

	0xF8,0xFC,0x04,0x04,0x04,0xFC,0xF8,0x00,0x07,0x0F,0x08,0x0E,0x3C,0x3F,0x27,0x00, // -Q-

	0x04,0xFC,0xFC,0x44,0xC4,0xFC,0x38,0x00,0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -R-

	0x18,0x3C,0x64,0x44,0xC4,0x9C,0x18,0x00,0x06,0x0E,0x08,0x08,0x08,0x0F,0x07,0x00, // -S-

	0x00,0x1C,0x0C,0xFC,0xFC,0x0C,0x1C,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -T-

	0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -U-

	0xFC,0xFC,0x00,0x00,0x00,0xFC,0xFC,0x00,0x01,0x03,0x06,0x0C,0x06,0x03,0x01,0x00, // -V-

	0xFC,0xFC,0x00,0x80,0x00,0xFC,0xFC,0x00,0x03,0x0F,0x0E,0x03,0x0E,0x0F,0x03,0x00, // -W-

	0x0C,0x3C,0xF0,0xC0,0xF0,0x3C,0x0C,0x00,0x0C,0x0F,0x03,0x00,0x03,0x0F,0x0C,0x00, // -X-

	0x00,0x3C,0x7C,0xC0,0xC0,0x7C,0x3C,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -Y-

	0x1C,0x0C,0x84,0xC4,0x64,0x3C,0x1C,0x00,0x0E,0x0F,0x09,0x08,0x08,0x0C,0x0E,0x00, // -Z-

    
    0x00,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -a-

	0x04,0xFC,0xFC,0x20,0x60,0xC0,0x80,0x00,0x08,0x0F,0x07,0x08,0x08,0x0F,0x07,0x00, // -b-

	0xC0,0xE0,0x20,0x20,0x20,0x60,0x40,0x00,0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00, // -c-

	0x80,0xC0,0x60,0x24,0xFC,0xFC,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -d-

	0xC0,0xE0,0xA0,0xA0,0xA0,0xE0,0xC0,0x00,0x07,0x0F,0x08,0x08,0x08,0x0C,0x04,0x00, // -e-

	0x40,0xF8,0xFC,0x44,0x0C,0x18,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -f-

	0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,0x27,0x6F,0x48,0x48,0x7F,0x3F,0x00,0x00, // -g-

	0x04,0xFC,0xFC,0x40,0x20,0xE0,0xC0,0x00,0x08,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -h-

	0x00,0x00,0x20,0xEC,0xEC,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -i-

	0x00,0x00,0x00,0x00,0x20,0xEC,0xEC,0x00,0x00,0x30,0x70,0x40,0x40,0x7F,0x3F,0x00, // -j-

	0x04,0xFC,0xFC,0x80,0xC0,0x60,0x20,0x00,0x08,0x0F,0x0F,0x01,0x03,0x0E,0x0C,0x00, // -k-

	0x00,0x00,0x04,0xFC,0xFC,0x00,0x00,0x00,0x00,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00, // -l-

	0xE0,0xE0,0x60,0xC0,0x60,0xE0,0xC0,0x00,0x0F,0x0F,0x00,0x0F,0x00,0x0F,0x0F,0x00, // -m-

	0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x00,0x0F,0x0F,0x00,0x00,0x0F,0x0F,0x00, // -n-

	0xC0,0xE0,0x20,0x20,0x20,0xE0,0xC0,0x00,0x07,0x0F,0x08,0x08,0x08,0x0F,0x07,0x00, // -o-

	0x20,0xE0,0xC0,0x20,0x20,0xE0,0xC0,0x00,0x40,0x7F,0x7F,0x48,0x08,0x0F,0x07,0x00, // -p-

	0xC0,0xE0,0x20,0x20,0xC0,0xE0,0x20,0x00,0x07,0x0F,0x08,0x48,0x7F,0x7F,0x40,0x00, // -q-

	0x20,0xE0,0xC0,0x60,0x20,0x60,0xC0,0x00,0x08,0x0F,0x0F,0x08,0x00,0x00,0x00,0x00, // -r-

	0x40,0xE0,0xA0,0x20,0x20,0x60,0x40,0x00,0x04,0x0C,0x09,0x09,0x0B,0x0E,0x04,0x00, // -s-

	0x20,0x20,0xF8,0xFC,0x20,0x20,0x00,0x00,0x00,0x00,0x07,0x0F,0x08,0x0C,0x04,0x00, // -t-

	0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,0x00,0x07,0x0F,0x08,0x08,0x07,0x0F,0x08,0x00, // -u-

	0x00,0xE0,0xE0,0x00,0x00,0xE0,0xE0,0x00,0x00,0x03,0x07,0x0C,0x0C,0x07,0x03,0x00, // -v-

	0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,0x07,0x0F,0x0C,0x07,0x0C,0x0F,0x07,0x00, // -w-

	0x20,0x60,0xC0,0x80,0xC0,0x60,0x20,0x00,0x08,0x0C,0x07,0x03,0x07,0x0C,0x08,0x00, // -x-

	0xE0,0xE0,0x00,0x00,0x00,0xE0,0xE0,0x00,0x47,0x4F,0x48,0x48,0x68,0x3F,0x1F,0x00, // -y-

	0x60,0x60,0x20,0xA0,0xE0,0x60,0x20,0x00,0x0C,0x0E,0x0B,0x09,0x08,0x0C,0x0C,0x00, // -z-
    
    0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00  // -:-
	
    
};

code unsigned char   *dyjzmz = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz:";


void Delay5us()		//@11.0592MHz
{
	unsigned char i;

	_nop_();
	i = 25;
	while (--i);
}


void dyjml(unsigned char a){
    dyjrs = 0;
    dyjdata = a;
    dyje = 1;
    Delay5us();
    dyje = 0;
}

void dyjsj(unsigned char a){
    dyjrs = 1;
    dyjdata = a;
    dyje  = 1;
    Delay5us();
    dyje = 0;
}

void dyjxy(unsigned char x,unsigned char y, unsigned char z,bit fb){
    unsigned char i;
    if(y<64){
        i = 0x40 +y;
        dyjcs1 = 1;
        dyjcs2 = 0;
    }
    else {
        i = 0x40 + y - 64;
        dyjcs1 = 0;
        dyjcs2 = 1;
    }
    TR1 = 0;
    dyjml(i);
    dyjml(0xb8 + x);
    if(fb) dyjsj(0xff - z);
    else dyjsj(z);
    TR1 = 1;
}

void dyjcsh(unsigned char x,unsigned char y){
    unsigned int i,j;
    dyjml(0x3f);
    dyjml(0xc0);
    for(i = x; i < y ; i++){
        for(j = 0; j<128;j++)
            dyjxy(i,j,0,0);
    }        
    i = 5;j = 100;
    while(i--) while(j--);;
}

void dyjsz(unsigned char r,unsigned char c, unsigned char s,bit fb){
    unsigned char i,j,d = 0;
    //SendData(s+55);SendString("\r\n");
    for(i = r; i <r+2; i++){
        for(j = c; j <c+8 ; j++){
            dyjxy(i,j,dyj16[s][d++],fb);
        }
        dyjcs1 = dyjcs2 = dyje = 0;
    }
}

void dyjhz(unsigned char r,unsigned char c, unsigned char s,bit fb){
    unsigned char i,j,d = 0;
    for(i = r; i <r+2; i++){
        for(j = c; j <c+16 ; j++){
            dyjxy(i,j,dyj32[s][d++],fb);
        }
        dyjcs1 = dyjcs2 = dyje = 0;
    }
}

void dyjzm(unsigned char r,unsigned char c, unsigned char *s,bit fb){
    unsigned char i,j,d = 0;
    //SendData(s[0]);SendString("\r\n");
    for(i = r; i < r + 2; i++){
        for(j = c; j < c + 8; j++){
            dyjxy(i,j,s[d++],fb);
        }
        dyjcs1 = dyjcs2 = dyje = 0;
    }
}
/*128液晶 函数结束-----------------------------------------------------------------------------------*/
void djmsz(unsigned char r, unsigned char c, unsigned int s,unsigned char w ,bit fb){
    while(w-- > 0 ){
        dyjsz(r,c+8*w,s%10,fb);
        s /= 10;
    }
}
void djmhz(unsigned char r, unsigned char c, unsigned char *s,bit fb){
    unsigned char i,j;
    for(i = 0; s[i] != 0 ;i++){
        for(j = 0; dyjhzz[j] != 0;j+= 2){
            if((s[i]==dyjhzz[j])&&(s[i+1]==dyjhzz[j+1])){
                //dyjhz(r,c+i*8,dyj32[j],fb);//2017.4.17change
                dyjhz(r,c+i*8,j/2,fb);
                break;
            }
        }
    }
}

void djmzm(unsigned char r, unsigned char c, unsigned char *s,bit fb){
    unsigned char i,j;
    for(i = 0; s[i]  != '\0' ;i++){
        for(j = 0; dyjzmz[j] != '\0';j++){
            if((s[i]==dyjzmz[j])){
                dyjsz(r,c+i*8,j,fb);
                break;
            }
        }
    }
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//

//===================================================================================//
//===================================================================================//
//                               function    串口中断
//===================================================================================//
//===================================================================================//
/*----------------------------
UART 中断服务程序
-----------------------------*/
void Uart() interrupt 4 using 1
{
    if (RI)
    {
        RI = 0;                 //清除RI位
    }
    if (TI)
    {
        TI = 0;                 //清除TI位
        busy = 0;               //清忙标志
    }
}

/*----------------------------
发送串口数据
----------------------------*/
void SendData(BYTE dat)
{
  
    while (busy);               //等待前面的数据发送完成
    ACC = dat;                  //获取校验位P (PSW.0)
    if (P)                      //根据P来设置校验位
    {
#if (PARITYBIT == ODD_PARITY)
        TB8 = 0;                //设置校验位为0
#elif (PARITYBIT == EVEN_PARITY)
        TB8 = 1;                //设置校验位为1
#endif
    }
    else
    {
#if (PARITYBIT == ODD_PARITY)
        TB8 = 1;                //设置校验位为1
#elif (PARITYBIT == EVEN_PARITY)
        TB8 = 0;                //设置校验位为0
#endif
    }
    busy = 1;
    SBUF = ACC;                 //写数据到UART数据寄存器
}

/*----------------------------
发送字符串
----------------------------*/
void SendString(char *s)
{
    while (*s)                  //检测字符串结束标志
    {
        SendData(*s++);         //发送当前字符
    }
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//


//===================================================================================//
//===================================================================================//
//                               function    1602液晶
//说明：函数使用前缀  xyj , 函数有写命令，写数据，写字母，写数字，写自制符号5个函数
//函数关系图：
//              xyjzm       xyjsz     xyjzzfh
//                 |          |         |
//                 ----------------------
//                            |
//                     -----------------
//                     |               |
//                   xyjml           xyjsj
//
//===================================================================================//
//===================================================================================//
//引脚定义
sfr P5   =   0xc8;//使用stc头文件的时候不需要
sbit xyje = P4^5;
sbit xyjrs = P5^5;
#define xyjdata P0
//自制字符显示与对应位置宏定义 格式 5*7 #define white	0x00
#define yellow	0x01
#define black	0x02
#define up		0x03
#define down	0x04
#define left	0x05
#define right	0x06
ucx xyjfhz[56] = {
			 0x04,0x0a,0x11,0x11,0x11,0x11,0x0a,0x04,//白球
			 0x04,0x0a,0x1b,0x15,0x15,0x1b,0x0a,0x04,//黄球
			 0x04,0x0e,0x1f,0x1f,0x1f,0x1f,0x0e,0x04,//黑球
			 0x00,0x04,0x0e,0x15,0x04,0x04,0x04,0x00,//向上
			 0x00,0x04,0x04,0x04,0x15,0x0e,0x04,0x00,//向下
			 0x00,0x04,0x08,0x1f,0x08,0x04,0x00,0x00,//向左	
			 0x00,0x04,0x02,0x1f,0x02,0x04,0x00,0x00 //向右
};
//函    数：xyjml
//功    能：写入命令道1602液晶屏
//返回参数：无
//输入参数： a液晶控制命令 
void xyjml(ucd a)
{
     TR1 = 0;
     xyjrs=0;Delay25us();
     xyjdata=a;
     xyje=1;Delay25us();
     xyje=0;
     TR1 = 1;
}
//函    数：xyjsj
//功    能：写入数据到1602液晶屏
//返回参数：无
//输入参数： a液晶控制shuju 
void xyjsj(ucd a)//这个xyjsj函数只能写一个字节
{
     TR1 = 0;
     xyjrs=1;Delay25us();
     xyjdata=a;
     xyje=1;Delay25us();
     xyje=0;
     TR1 = 1;
}
//函    数：xyjzm
//功    能：写入字母到1602液晶屏固定位置
//返回参数：无
//输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,*s显示字符串 
void xyjzm(ucd row,ucd  col , ucd *s){
    ucx i;
	if(row == 0) xyjml(0x80 + col);
	else if(row ==1 ) xyjml(0xc0 + col);
    i = 0;
    while(s[i] != '\0'){
        xyjsj(s[i]);
        i++;
    }
}
//函    数：xyjsz
//功    能：写入数字到160液晶屏固定位置
//返回参数：无
//输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,count显示数字
void xyjsz(ucd  row,ucd col , scd wei ,long count){
	while(wei != 0){
		if(row == 0) xyjml(0x80 + col + wei--);
		else if(row ==1 ) xyjml(0xc0 + col + wei--);
		xyjsj(count % 10 + 48);
		count /= 10;
	}
}
//函    数：xyjsz
//功    能：写入符号到1602液晶屏固定位置
//返回参数：无
//输入参数： row显示的行（范围0~1）,col显示的列（范围0~15）,dat显示符号
void xyjzzfh(ucd row ,ucd col,ucd dat){
	if(row == 0) xyjml(0x80 + col);
		else if(row ==1 ) xyjml(0xc0 + col);
	xyjsj(dat);
}
//函    数：xyjcsh
//功    能：1602液晶屏初始化
//返回参数：无
//输入参数：无
void xyjcsh()
{	
	ucd i =0;
    xyje=0;
    xyjml(0x38);Delay50ms();
    xyjml(0x0c);Delay50ms();
    xyjml(0x06);Delay50ms();
    xyjml(0x01);Delay50ms();
    //自制字符写入
	xyjml(0x40);Delay50ms();
    for(i = 0;i<56;i++){
		xyjsj(xyjfhz[i]);
	}
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//


//===================================================================================//
//===================================================================================//
//                               function    4*4键盘
//===================================================================================//
//===================================================================================//
#define jpca 1500
#define jpda 1000
#define jpdata P2
ucx jpjz;
ucd jpxh;
uix jpsj;

ucc jplie[4] = {0xfe,0xfd,0xfb,0xf7};
ucc jpsao[] = {0xee,0xde,0xbe,0x7e,
               0xed,0xdd,0xbd,0x7d,
               0xeb,0xdb,0xbb,0x7b,
               0xe7,0xd7,0xb7,0x77,
              };
ucd jphm(){
    ucx i,k = 16;
    jpdata = 0xf0;
    if(jpdata != 0xf0){
        if(jpxh ==7){
            for(i = 0;i < 4 ; i++){
                jpdata = jplie[i];
                if(jpdata != jplie[i]){
                    k = jpdata;
                }
            }
        }
        jpxh++;
        if(jpxh > jpsj){
            jpsj = jpca;
            jpxh = 0;
        }
    }
    else {
        jpxh = 0;
        jpsj = jpca;
    };
    return k;
}
void jpsm(){
    ucx i,j ;
    j = jphm();
    if(j!=16){
        for(i =0 ;i<16;i++){
            if(jpsao[i] == j){
                jpjz = i;
            }
        }
    }
}
ucd jprun(){
    jpsm();
    if(jpxh ==7){
        jpsm();
        return jpjz;
    }
    return 16;
}

/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/
/*                                  function end
/*-----------------------------------------------------------------------------------*/
/*-----------------------------------------------------------------------------------*/


/*===================================================================================*/
/*===================================================================================*/
/*                               function   直流电机
/*===================================================================================*/
/*功能：控制直流电机正反转以及停止等动作，
/*===================================================================================*/
//使用数据定义
//空点，方向，运行，空点外  
bit zlwei,zlfx,zlyx,zlout;
//空点计数（到计数）
char data zljs;
//使用扩展模块输出使用
ucx zldj;
//电机3种状态
#define zltz() zldj = 3
#define zlfz() zldj = 2
#define zlzz() zldj = 1
//函    数：zlrun()
//功    能：直流电机运行函数，放在主程序末端
//返回参数：无
//输入参数：无
void zlrun(){
    //电动机运行
    if(zlyx){
        //直流电机动作控制部分
        if(zljs <= 0) {zltz();zljs = 0;}
        else {if(zlfx) zlzz(); else if(!zlfx) zlfz();};
        //直流电机空点、计数处理部分
        if((zlout != 1)&&(zlwei == 1)) {zljs--;zlwei = 0;}
        if((zlout == 1)&&(zlwei == 0)) {zlwei = 1;}
    } 
    //电动机停止
    else zltz();
}
//函    数：zlsd()
//功    能：电动机设置函数，使用时输入一下参数
//返回参数：无
//输入参数：fxz直流电运动机方向（0-~1),jsz直流电机需要旋转的空点数（0~255）)
void zlsd(bit fx,ucd jsz){zlfx = fx; zljs = jsz;zlyx = 1;}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//

//===================================================================================//
//===================================================================================//
//                               function   步进
//===================================================================================//
//===================================================================================//
bit bjrl;
bit bjdir ;
sbit bjcp = P3^2;
uix bjcsz = 764;
ucd bjjs;
static unsigned int bjjsz;
static unsigned int bjsdz;

void kzsc();
void read165();
bit bjyx;

void bjfw(){
    bjcp = 1;bjjsz = 0;
    bjdir = 1;kzsc();//写方向方向与at89s52版本刚好相反
    //bjjsz =0;
    while(bjrl == 0){
        Delay25us();Delay25us();Delay25us();;
        read165();
        while(bjrl == 0){
            bjcp =1;Delay25us();
            bjcp = 0;Delay25us();
            read165();
            //xyjsz(1,8,7,bjjsz++);
        }
    }
    
    
    bjdir = 0;kzsc();
    while(bjcsz > 0){
        bjcp =1;Delay25us();Delay25us();;
        bjcp = 0;Delay25us();Delay25us();;
        read165();
        bjcsz--;
    }
    
    bjjsz = 0;
    bjyx = 0;
    bjsdz = 0;
}

void bjsd(ucd set){
    bjsdz = set *1370;
    if(bjsdz > bjjsz) {bjdir =0 ;bjyx = 1;};
    if(bjsdz < bjjsz) {bjdir = 1; bjyx = 1;};
    kzsc();//写方向方向与at89s52版本刚好相反
}

void bjrun(){
    if(bjjs++ > 1)
    {
        bjcp = 1;
        if(bjyx ==1 ){
            bjcp = 0;
            if(bjdir) bjjsz--;else bjjsz++;
            if(bjjsz == bjsdz) bjyx = 0;
        }
        bjjs = 0;
    }
}

//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------/

//===================================================================================//
//===================================================================================//
//                               function    机械手
//===================================================================================//
//===================================================================================//


ucd jxsdj;//输出
ucd jxssr;//输入
ucd jxszt;
ucx jxsq1,jxsq2;
ucd jxswz;
static ucd jxsdzz[8];
bit jxsyx;

#define jxszy  1
#define jxsyy  2
#define jxsjf  4
#define jxssj  8

#define jxsgw1 jxssr&0x01
#define jxsgw2 jxssr&0x02
#define jxsgw3 jxssr&0x04
#define jxsxx  jxssr&0x08
#define jxsjj  jxssr&0x10
#define jxsgq  jxssr&0x20
#define jxsgd1 jxssr&0x40
#define jxsgd2 jxssr&0x80

bit jxsdz(ucd dz){
    bit zt = 0;
    switch(dz){
        case 0:{};break;
        case 1:{
            if(jxsgw3) jxsdj &= ~jxszy ; 
            else {jxsdj |= jxszy ;zt = 1;}
        };break;
        case 2:{
            if(jxsgw2) jxsdj &= ~jxszy ;
            else { jxsdj |= jxszy ;zt = 1;}
        };break;
        case 3:{
            if(jxsgw1) jxsdj &= ~jxsyy;
            else { jxsdj |= jxsyy ;zt = 1;}
        };break;
        case 4:{
            if(jxsgw2)   jxsdj &= ~jxsyy;
            else { jxsdj |= jxsyy;zt = 1;}
        };break;
        case 5:{};break;
        case 6:{};break;
        case 7:{};break;
        case 8:{};break;
        case 9:{};break;
    }
    return zt;
}

bit jxssd(long  dz){
    bit zt = 0;
    char i ;
    if(jxswz > 7){
        for(i = 7; i>0 ;i--){
            jxsdzz[i] = 0;
            jxsdzz[i] = dz%10;
            dz /= 10;
        }
        zt = 1;
        jxswz = 0;
    }
    return zt;
}

jxsrun(){
    if(jxsyx){
        if(jxswz < 8){
            if(jxsdz(jxsdzz[jxswz]))
                jxswz++;
        }
    }
    //else {jxsdj &= ~((jxszy + jxsyy)<<4);};
}

void jxsfw(){
    jxswz = 9;
    jxssd(1);
    while(jxswz < 8){
        jxsrun();
    }
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//


//===================================================================================//
//===================================================================================//
//                               function   74ls165
//===================================================================================//
//===================================================================================//
sbit QH = P3^3;
sbit CLK  = P3^5;
sbit SL =   P3^4;
uid kzxh,kzdata;

void read165(){
    
    ncx i;
    SL = 0;
    kzxh = 0;Delay25us();
    SL = 1;
    for(i = 10; i > 0;i--){
        CLK = 0;Delay25us();
        kzxh <<= 1;
        if(QH) kzxh |= 0X01;
        CLK = 1;
        
    }
    if(kzdata != kzxh) {
        kzdata = kzxh;
        jxssr = (unsigned char )kzdata >> 2;
        bjrl =   kzdata  & 0x01;
        zlout =   kzdata & 0x02;//djmsz(2,100,zlout,1,0);
    }
}


//===================================================================================//
//===================================================================================//
//                               function    74hc595
//===================================================================================//
//===================================================================================//
sbit hc595_ds   = P3^7;
sbit hc595_stcp = P3^6;
sbit hc595_shcp = P3^5;

ucx kzsj;
void kzsc(){
    ucd i;
    ucd j = jxsdj<<4 | zldj<<2 | bjdir ;
    if(kzsj !=  j){
        for(i= 0; i<8;i++){
            hc595_shcp  = 0;
            hc595_ds    = j & (0x80 >> i);
            hc595_shcp  = 1;
        }
        hc595_stcp = 0;Delay25us();
        hc595_stcp = 1;
    }
    kzsj = j;
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                  function end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//


//===================================================================================//
//===================================================================================//
//                              subjust 
//===================================================================================//
//===================================================================================//


void main()
{
    ucd ABC;
    ucd key;
    P0M0 = 0xFF;
    P0M1 = 0X00;
    P1M0 = 0x00;
    P1M1 = 0x00;
    P2M0 = 0x00;
    P2M1 = 0x00;
    P3M0 = 0xFF;
    P3M1 = 0x00;
    P4M0 = 0x00;//2F
    P4M1 = 0x00;
    P5M0 = 0x00;//20
    P5M1 = 0x00;
    P6M0 = 0x00;
    P6M1 = 0x00;
    P7M0 = 0x00;
    P7M1 = 0x00;


    xyjcsh();
    dyjcsh(0,8);
    
    
    AUXR = 0;
    initt1();
    SCON = 0x50;                //8位可变波特
    T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
    T2H = (65536 - (FOSC/4/BAUD))>>8;
    AUXR |= 0x14; 
    AUXR |= 0x01;               //此处AUXR必须分两次赋值
    ES = 1; 
    
    EA  = 1;
    //InitADC();
    //hc595_write (0); hc595_write (0xFF);
               
                     //初始化ADC
    //SendString("STC15F2K60S2\r\nUart Test !\r\n");
    smgdps(3);
    zldj = 0x03;
    jxsdj = 0x0f;
    xyjcsh();
    xyjsz(1,7,5,789);
    //smgxhc(0,4,124);
    //smgxhc(1,4,12);
    //bjrl = 1;
    read165();
    bjfw();
    bjjs = 0;
    //jxsfw();
    while (1){
			 
        unsigned char xdata i;
        //smgxhc(0,8,12345678);
			  //smgrun();
        key = jprun();
        /*GetADCResult();
        P3 = 0;
   
        for( i = 0; i < 8 ;i++)
        {
            djmsz(0,i*16,jxsdzz[i],1,i%2);
        }
        */
        
        //i = kzdata & 0X03;
        //djmsz(4,0,i,3,0);
        //i = kzdata>>2;
        //djmsz(4,32,i,3,0);

        //djmsz(6,0,kzxh,7,0);
        
        //xyjsz(0,0,1,zlout);
        //xyjsz(0,4,1,zlwei);
        
        //xyjzzfh(1,0,up);
        //xyjzm(1,5,"blue");
        if(key != 16) djmsz(4,72,key,3,0);
        //djmsz(4,72,zldj,3,0);
        djmsz(6,72,ABC++,3,0);
        //smgrun();
  
        //str(1,12,"fx:");

        //djmsz(2, 0,count,5,0);
        //djmsz(2, 0,"白",3,0);
        //djmsz(4, 0,dyj32[1],3,0);
        //djmsz(2,0,"白",6,0);
        //djmzm(0,0,"HELLO",0);
        
        //djmhz(4,0,"两岸猿声啼不住，",0);
        //djmhz(6,0,"轻舟已过万重山：",0);
        //dyjsz(4,0,10,0);
        //dyjhz(6,63,"日",0);
        //djmzm(4,0,"h e l l o w",0);
				//if(key != 16){
				//	xyjsz(1,8,7,key);
				//	djmhz(0,0,"朝辞白帝彩云间，",0);
				//	djmhz(2,0,"千里江陵一日还。",1);
				//}
        
        //Delay50ms();
       
        //smgxhc(0,4,GetADCResult(7));
        //smgdps(3);
        
        
       /*
        if(key != 16){
            smgxhc(0,4,key);
            //djmsz(2,0,key,2,1);
            zlsd(0,key);
            //bjsd(key);
            /*
            switch(key){
                //case  1:{zldj=0; zldj = 1;}break;
                //case  2:{zldj=0; zldj = 2;}break;
                //case  3:{zldj=3 ;           }break;
                case  4:{jxsdj |= 1;}break;
                case  5:{jxsdj |= 2;}break;
                case  6:{jxsdj |= 4;}break;
                case  7:{jxsdj |= 8;}break;
                case  8:{jxsdj &= 0x0e;}break;
                case  9:{jxsdj &= 0x0d;}break;
                case 10:{jxsdj &= 0x0b;}break;
                case 11:{jxsdj &= 0x07;}break;
            }   
            if(key == 3) jxssd(3);
            if(key == 1) jxssd(4);
            if(key == 2) jxssd(2);
            if(key == 4) jxssd(1);
        }
        */
        //smgxhc(0,4,1);
        smgxhc(4,4,ABC);
        //xyjsz(0,7,5,ABC);
		//smgxhc(4,4,0000);
        /*
        xyjsz(0,7,5,adz);
        {
            bjsd(adz/17);
        }
        //xyjsz(1,7,5,adjs);
        */
        //smgxhc(0,4,bjsdz);
        //smgxhc(4,4,bjjsz);
        //xyjsz(1,1,3,adjs);
        //SendData(count);
        //xyjsz(1,6,1,(ucd)bjrl);
        //xyjsz(1,8,7,bjsdz);
        
        //djmsz(4,20,jxssr,5,1);
        
        
        //zlsd(0,key);
        //read165();
        //zlrun();
        //kzsc();
        //hc595_write (jxsdj<<4 | zldj<<2);
        //kzsc(jxsdj<<4 | zldj<<2);
        //hc595_write(count);
        //SendString("STC15F2K60S2\r\nUart Test !\r\n");
        //bjrun();
        //jxsrun();
	}
}
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
//                                 subjust end
//-----------------------------------------------------------------------------------//
//-----------------------------------------------------------------------------------//
